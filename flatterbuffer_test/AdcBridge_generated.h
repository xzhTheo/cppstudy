// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ADCBRIDGE_COM_NIO_MAP_ADAS_FLAT_H_
#define FLATBUFFERS_GENERATED_ADCBRIDGE_COM_NIO_MAP_ADAS_FLAT_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
              "Non-compatible flatbuffers version included");

namespace com
{
namespace nio
{
namespace map
{
namespace adas
{
namespace flat
{

struct TrafficSign;
struct TrafficSignBuilder;

struct Position;
struct PositionBuilder;

struct Segment;
struct SegmentBuilder;

struct Stub;
struct StubBuilder;

struct ProfileShort;
struct ProfileShortBuilder;

struct ProfileLong;
struct ProfileLongBuilder;

struct MetaData;
struct MetaDataBuilder;

struct CustomMessage;
struct CustomMessageBuilder;

struct MapMatchInfo;
struct MapMatchInfoBuilder;

struct SpeedLimitInfo;
struct SpeedLimitInfoBuilder;

struct LaneInfo;
struct LaneInfoBuilder;

struct TurnInfo;
struct TurnInfoBuilder;

struct EnterNopRoadInfo;
struct EnterNopRoadInfoBuilder;

struct ExitNopRoadInfo;
struct ExitNopRoadInfoBuilder;

struct EnterNopRampInfo;
struct EnterNopRampInfoBuilder;

struct HeartBeatInfo;
struct HeartBeatInfoBuilder;

struct GPSLocation;
struct GPSLocationBuilder;

struct AdasInfoData;
struct AdasInfoDataBuilder;

struct HighPrecisionMapQueryRequest;
struct HighPrecisionMapQueryRequestBuilder;

struct HighPrecisionMapQueryResponse;
struct HighPrecisionMapQueryResponseBuilder;

struct HighPrecisionMapPoint;
struct HighPrecisionMapPointBuilder;

struct HighPrecisionMapPointList;
struct HighPrecisionMapPointListBuilder;

struct NowLocationHPMapStatus;
struct NowLocationHPMapStatusBuilder;

struct HighPrecisionQueryEnterResponse;
struct HighPrecisionQueryEnterResponseBuilder;

struct NopInfoData;
struct NopInfoDataBuilder;

struct NodeInfoData;
struct NodeInfoDataBuilder;

struct NavMapLoc;
struct NavMapLocBuilder;

struct NavMapLocVersion2;
struct NavMapLocVersion2Builder;

struct RouteMatchRequest;
struct RouteMatchRequestBuilder;

struct TBTSegmentAction;
struct TBTSegmentActionBuilder;

struct SearchByRoadNameRequest;
struct SearchByRoadNameRequestBuilder;

struct SDLinkInfo;
struct SDLinkInfoBuilder;

struct SearchByRouteRequest;
struct SearchByRouteRequestBuilder;

struct FourDEventFilter;
struct FourDEventFilterBuilder;

struct FourDCruisePointsRequest;
struct FourDCruisePointsRequestBuilder;

struct SDHDMatchList;
struct SDHDMatchListBuilder;

struct RouteMatchResponse;
struct RouteMatchResponseBuilder;

struct NADInfo;
struct NADInfoBuilder;

struct RoadCondition;
struct RoadConditionBuilder;

struct RoadConditionInfo;
struct RoadConditionInfoBuilder;

struct ResetPredictiveTree;
struct ResetPredictiveTreeBuilder;

struct HDRoutesEvent;
struct HDRoutesEventBuilder;

struct DynamicTurnKindInfo;
struct DynamicTurnKindInfoBuilder;

struct HDRoutesEvents;
struct HDRoutesEventsBuilder;

struct SDMapTable;
struct SDMapTableBuilder;

struct LaneInfoList;
struct LaneInfoListBuilder;

struct BumpyPoisInfo;
struct BumpyPoisInfoBuilder;

struct BumpyPoi;
struct BumpyPoiBuilder;

struct BumpyPoiAttribute;
struct BumpyPoiAttributeBuilder;

struct BumpyPoiExtaAttribute;
struct BumpyPoiExtaAttributeBuilder;

struct BumpyPoiPoints;
struct BumpyPoiPointsBuilder;

struct LightState;
struct LightStateBuilder;

struct LightInfo;
struct LightInfoBuilder;

struct TrafficLightCountdown;
struct TrafficLightCountdownBuilder;

struct TrafficLightCountdownList;
struct TrafficLightCountdownListBuilder;

struct ParallelRoad;
struct ParallelRoadBuilder;

enum ReliableState : int32_t
{
    ReliableState_RS_NONE = 0,
    ReliableState_UNRELIABLE = 1,
    ReliableState_UNRELIABLE_ROUTING = 2,
    ReliableState_UNRELIABLE_YAWING = 3,
    ReliableState_UNRELIABLE_SWITCHING = 4,
    ReliableState_UNRELIABLE_UNKNOWN = 5,
    ReliableState_UNRELIABLE_MAX = 6,
    ReliableState_RELIABLE = 7,
    ReliableState_MIN = ReliableState_RS_NONE,
    ReliableState_MAX = ReliableState_RELIABLE
};

inline const ReliableState (&EnumValuesReliableState())[8]
{
    static const ReliableState values[] = {
        ReliableState_RS_NONE,
        ReliableState_UNRELIABLE,
        ReliableState_UNRELIABLE_ROUTING,
        ReliableState_UNRELIABLE_YAWING,
        ReliableState_UNRELIABLE_SWITCHING,
        ReliableState_UNRELIABLE_UNKNOWN,
        ReliableState_UNRELIABLE_MAX,
        ReliableState_RELIABLE
    };
    return values;
}

inline const char* const* EnumNamesReliableState()
{
    static const char* const names[9] =
    {
        "RS_NONE",
        "UNRELIABLE",
        "UNRELIABLE_ROUTING",
        "UNRELIABLE_YAWING",
        "UNRELIABLE_SWITCHING",
        "UNRELIABLE_UNKNOWN",
        "UNRELIABLE_MAX",
        "RELIABLE",
        nullptr
    };
    return names;
}

inline const char* EnumNameReliableState(ReliableState e)
{
    if (::flatbuffers::IsOutRange(e, ReliableState_RS_NONE, ReliableState_RELIABLE)) return "";

    const size_t index = static_cast<size_t>(e);
    return EnumNamesReliableState()[index];
}

enum NavigationState : int32_t
{
    NavigationState_NS_NONE = 0,
    NavigationState_ROUTE_CRUISING = 1,
    NavigationState_ROAMING = 2,
    NavigationState_NAVIGATING = 3,
    NavigationState_MIN = NavigationState_NS_NONE,
    NavigationState_MAX = NavigationState_NAVIGATING
};

inline const NavigationState (&EnumValuesNavigationState())[4]
{
    static const NavigationState values[] = {
        NavigationState_NS_NONE,
        NavigationState_ROUTE_CRUISING,
        NavigationState_ROAMING,
        NavigationState_NAVIGATING
    };
    return values;
}

inline const char* const* EnumNamesNavigationState()
{
    static const char* const names[5] =
    {
        "NS_NONE",
        "ROUTE_CRUISING",
        "ROAMING",
        "NAVIGATING",
        nullptr
    };
    return names;
}

inline const char* EnumNameNavigationState(NavigationState e)
{
    if (::flatbuffers::IsOutRange(e, NavigationState_NS_NONE, NavigationState_NAVIGATING)) return "";

    const size_t index = static_cast<size_t>(e);
    return EnumNamesNavigationState()[index];
}

enum RoadClass : int32_t
{
    RoadClass_R_NONE = 0,
    RoadClass_HIGHWAY = 1,
    RoadClass_URBANHIGHWAY = 2,
    RoadClass_NATIONALROAD = 3,
    RoadClass_PROVINCIALROAD = 4,
    RoadClass_COUNTYROAD = 5,
    RoadClass_TOWNROAD = 6,
    RoadClass_OTHERROAD = 7,
    RoadClass_NONNAVIGATIONROAD = 8,
    RoadClass_WALKINGROAD = 9,
    RoadClass_FERRY = 10,
    RoadClass_R_MAX = 11,
    RoadClass_MIN = RoadClass_R_NONE,
    RoadClass_MAX = RoadClass_R_MAX
};

inline const RoadClass (&EnumValuesRoadClass())[12]
{
    static const RoadClass values[] = {
        RoadClass_R_NONE,
        RoadClass_HIGHWAY,
        RoadClass_URBANHIGHWAY,
        RoadClass_NATIONALROAD,
        RoadClass_PROVINCIALROAD,
        RoadClass_COUNTYROAD,
        RoadClass_TOWNROAD,
        RoadClass_OTHERROAD,
        RoadClass_NONNAVIGATIONROAD,
        RoadClass_WALKINGROAD,
        RoadClass_FERRY,
        RoadClass_R_MAX
    };
    return values;
}

inline const char* const* EnumNamesRoadClass()
{
    static const char* const names[13] =
    {
        "R_NONE",
        "HIGHWAY",
        "URBANHIGHWAY",
        "NATIONALROAD",
        "PROVINCIALROAD",
        "COUNTYROAD",
        "TOWNROAD",
        "OTHERROAD",
        "NONNAVIGATIONROAD",
        "WALKINGROAD",
        "FERRY",
        "R_MAX",
        nullptr
    };
    return names;
}

inline const char* EnumNameRoadClass(RoadClass e)
{
    if (::flatbuffers::IsOutRange(e, RoadClass_R_NONE, RoadClass_R_MAX)) return "";

    const size_t index = static_cast<size_t>(e);
    return EnumNamesRoadClass()[index];
}

enum GPSLocationType : int32_t
{
    GPSLocationType_G_NOT_VALID = 0,
    GPSLocationType_RAMP_START = 1,
    GPSLocationType_RAMP_END = 2,
    GPSLocationType_TBT_POINT = 3,
    GPSLocationType_MIN = GPSLocationType_G_NOT_VALID,
    GPSLocationType_MAX = GPSLocationType_TBT_POINT
};

inline const GPSLocationType (&EnumValuesGPSLocationType())[4]
{
    static const GPSLocationType values[] = {
        GPSLocationType_G_NOT_VALID,
        GPSLocationType_RAMP_START,
        GPSLocationType_RAMP_END,
        GPSLocationType_TBT_POINT
    };
    return values;
}

inline const char* const* EnumNamesGPSLocationType()
{
    static const char* const names[5] =
    {
        "G_NOT_VALID",
        "RAMP_START",
        "RAMP_END",
        "TBT_POINT",
        nullptr
    };
    return names;
}

inline const char* EnumNameGPSLocationType(GPSLocationType e)
{
    if (::flatbuffers::IsOutRange(e, GPSLocationType_G_NOT_VALID, GPSLocationType_TBT_POINT)) return "";

    const size_t index = static_cast<size_t>(e);
    return EnumNamesGPSLocationType()[index];
}

enum NodeInfo : uint8_t
{
    NodeInfo_NONE = 0,
    NodeInfo_mapMatchInfo = 1,
    NodeInfo_speedLimitInfo = 2,
    NodeInfo_laneInfo = 3,
    NodeInfo_turnInfo = 4,
    NodeInfo_enterNopRoadInfo = 5,
    NodeInfo_exitNopRoadInfo = 6,
    NodeInfo_enterNopRampInfo = 7,
    NodeInfo_heartBeatInfo = 8,
    NodeInfo_laneInfoList = 9,
    NodeInfo_parallelRoad = 10,
    NodeInfo_MIN = NodeInfo_NONE,
    NodeInfo_MAX = NodeInfo_parallelRoad
};

inline const NodeInfo (&EnumValuesNodeInfo())[11]
{
    static const NodeInfo values[] = {
        NodeInfo_NONE,
        NodeInfo_mapMatchInfo,
        NodeInfo_speedLimitInfo,
        NodeInfo_laneInfo,
        NodeInfo_turnInfo,
        NodeInfo_enterNopRoadInfo,
        NodeInfo_exitNopRoadInfo,
        NodeInfo_enterNopRampInfo,
        NodeInfo_heartBeatInfo,
        NodeInfo_laneInfoList,
        NodeInfo_parallelRoad
    };
    return values;
}

inline const char* const* EnumNamesNodeInfo()
{
    static const char* const names[12] =
    {
        "NONE",
        "mapMatchInfo",
        "speedLimitInfo",
        "laneInfo",
        "turnInfo",
        "enterNopRoadInfo",
        "exitNopRoadInfo",
        "enterNopRampInfo",
        "heartBeatInfo",
        "laneInfoList",
        "parallelRoad",
        nullptr
    };
    return names;
}

inline const char* EnumNameNodeInfo(NodeInfo e)
{
    if (::flatbuffers::IsOutRange(e, NodeInfo_NONE, NodeInfo_parallelRoad)) return "";

    const size_t index = static_cast<size_t>(e);
    return EnumNamesNodeInfo()[index];
}

template<typename T> struct NodeInfoTraits
{
    static const NodeInfo enum_value = NodeInfo_NONE;
};

template<> struct NodeInfoTraits<com::nio::map::adas::flat::MapMatchInfo>
{
    static const NodeInfo enum_value = NodeInfo_mapMatchInfo;
};

template<> struct NodeInfoTraits<com::nio::map::adas::flat::SpeedLimitInfo>
{
    static const NodeInfo enum_value = NodeInfo_speedLimitInfo;
};

template<> struct NodeInfoTraits<com::nio::map::adas::flat::LaneInfo>
{
    static const NodeInfo enum_value = NodeInfo_laneInfo;
};

template<> struct NodeInfoTraits<com::nio::map::adas::flat::TurnInfo>
{
    static const NodeInfo enum_value = NodeInfo_turnInfo;
};

template<> struct NodeInfoTraits<com::nio::map::adas::flat::EnterNopRoadInfo>
{
    static const NodeInfo enum_value = NodeInfo_enterNopRoadInfo;
};

template<> struct NodeInfoTraits<com::nio::map::adas::flat::ExitNopRoadInfo>
{
    static const NodeInfo enum_value = NodeInfo_exitNopRoadInfo;
};

template<> struct NodeInfoTraits<com::nio::map::adas::flat::EnterNopRampInfo>
{
    static const NodeInfo enum_value = NodeInfo_enterNopRampInfo;
};

template<> struct NodeInfoTraits<com::nio::map::adas::flat::HeartBeatInfo>
{
    static const NodeInfo enum_value = NodeInfo_heartBeatInfo;
};

template<> struct NodeInfoTraits<com::nio::map::adas::flat::LaneInfoList>
{
    static const NodeInfo enum_value = NodeInfo_laneInfoList;
};

template<> struct NodeInfoTraits<com::nio::map::adas::flat::ParallelRoad>
{
    static const NodeInfo enum_value = NodeInfo_parallelRoad;
};

bool VerifyNodeInfo(::flatbuffers::Verifier& verifier, const void* obj, NodeInfo type);
bool VerifyNodeInfoVector(::flatbuffers::Verifier& verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>>* values, const ::flatbuffers::Vector<uint8_t>* types);

enum AdasInfo : uint8_t
{
    AdasInfo_NONE = 0,
    AdasInfo_trafficSign = 1,
    AdasInfo_position = 2,
    AdasInfo_segment = 3,
    AdasInfo_stub = 4,
    AdasInfo_profileShort = 5,
    AdasInfo_profileLong = 6,
    AdasInfo_metaData = 7,
    AdasInfo_customMessage = 8,
    AdasInfo_MIN = AdasInfo_NONE,
    AdasInfo_MAX = AdasInfo_customMessage
};

inline const AdasInfo (&EnumValuesAdasInfo())[9]
{
    static const AdasInfo values[] = {
        AdasInfo_NONE,
        AdasInfo_trafficSign,
        AdasInfo_position,
        AdasInfo_segment,
        AdasInfo_stub,
        AdasInfo_profileShort,
        AdasInfo_profileLong,
        AdasInfo_metaData,
        AdasInfo_customMessage
    };
    return values;
}

inline const char* const* EnumNamesAdasInfo()
{
    static const char* const names[10] =
    {
        "NONE",
        "trafficSign",
        "position",
        "segment",
        "stub",
        "profileShort",
        "profileLong",
        "metaData",
        "customMessage",
        nullptr
    };
    return names;
}

inline const char* EnumNameAdasInfo(AdasInfo e)
{
    if (::flatbuffers::IsOutRange(e, AdasInfo_NONE, AdasInfo_customMessage)) return "";

    const size_t index = static_cast<size_t>(e);
    return EnumNamesAdasInfo()[index];
}

template<typename T> struct AdasInfoTraits
{
    static const AdasInfo enum_value = AdasInfo_NONE;
};

template<> struct AdasInfoTraits<com::nio::map::adas::flat::TrafficSign>
{
    static const AdasInfo enum_value = AdasInfo_trafficSign;
};

template<> struct AdasInfoTraits<com::nio::map::adas::flat::Position>
{
    static const AdasInfo enum_value = AdasInfo_position;
};

template<> struct AdasInfoTraits<com::nio::map::adas::flat::Segment>
{
    static const AdasInfo enum_value = AdasInfo_segment;
};

template<> struct AdasInfoTraits<com::nio::map::adas::flat::Stub>
{
    static const AdasInfo enum_value = AdasInfo_stub;
};

template<> struct AdasInfoTraits<com::nio::map::adas::flat::ProfileShort>
{
    static const AdasInfo enum_value = AdasInfo_profileShort;
};

template<> struct AdasInfoTraits<com::nio::map::adas::flat::ProfileLong>
{
    static const AdasInfo enum_value = AdasInfo_profileLong;
};

template<> struct AdasInfoTraits<com::nio::map::adas::flat::MetaData>
{
    static const AdasInfo enum_value = AdasInfo_metaData;
};

template<> struct AdasInfoTraits<com::nio::map::adas::flat::CustomMessage>
{
    static const AdasInfo enum_value = AdasInfo_customMessage;
};

bool VerifyAdasInfo(::flatbuffers::Verifier& verifier, const void* obj, AdasInfo type);
bool VerifyAdasInfoVector(::flatbuffers::Verifier& verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>>* values, const ::flatbuffers::Vector<uint8_t>* types);

enum ResponseStatus : int32_t
{
    ResponseStatus_RESP_NOT_VALID = 0,
    ResponseStatus_RESP_VALID = 1,
    ResponseStatus_MIN = ResponseStatus_RESP_NOT_VALID,
    ResponseStatus_MAX = ResponseStatus_RESP_VALID
};

inline const ResponseStatus (&EnumValuesResponseStatus())[2]
{
    static const ResponseStatus values[] = {
        ResponseStatus_RESP_NOT_VALID,
        ResponseStatus_RESP_VALID
    };
    return values;
}

inline const char* const* EnumNamesResponseStatus()
{
    static const char* const names[3] =
    {
        "RESP_NOT_VALID",
        "RESP_VALID",
        nullptr
    };
    return names;
}

inline const char* EnumNameResponseStatus(ResponseStatus e)
{
    if (::flatbuffers::IsOutRange(e, ResponseStatus_RESP_NOT_VALID, ResponseStatus_RESP_VALID)) return "";

    const size_t index = static_cast<size_t>(e);
    return EnumNamesResponseStatus()[index];
}

enum HighPrecisionMapGPSStatus : int32_t
{
    HighPrecisionMapGPSStatus_HP_GPS_STATUS_NOT_VALID = 0,
    HighPrecisionMapGPSStatus_IN_HIGH_PRECISION_MAP_AREA = 1,
    HighPrecisionMapGPSStatus_NOT_IN_HIGH_PRECISION_MAP_AREA = 2,
    HighPrecisionMapGPSStatus_MIN = HighPrecisionMapGPSStatus_HP_GPS_STATUS_NOT_VALID,
    HighPrecisionMapGPSStatus_MAX = HighPrecisionMapGPSStatus_NOT_IN_HIGH_PRECISION_MAP_AREA
};

inline const HighPrecisionMapGPSStatus (&EnumValuesHighPrecisionMapGPSStatus())[3]
{
    static const HighPrecisionMapGPSStatus values[] = {
        HighPrecisionMapGPSStatus_HP_GPS_STATUS_NOT_VALID,
        HighPrecisionMapGPSStatus_IN_HIGH_PRECISION_MAP_AREA,
        HighPrecisionMapGPSStatus_NOT_IN_HIGH_PRECISION_MAP_AREA
    };
    return values;
}

inline const char* const* EnumNamesHighPrecisionMapGPSStatus()
{
    static const char* const names[4] =
    {
        "HP_GPS_STATUS_NOT_VALID",
        "IN_HIGH_PRECISION_MAP_AREA",
        "NOT_IN_HIGH_PRECISION_MAP_AREA",
        nullptr
    };
    return names;
}

inline const char* EnumNameHighPrecisionMapGPSStatus(HighPrecisionMapGPSStatus e)
{
    if (::flatbuffers::IsOutRange(e, HighPrecisionMapGPSStatus_HP_GPS_STATUS_NOT_VALID, HighPrecisionMapGPSStatus_NOT_IN_HIGH_PRECISION_MAP_AREA)) return "";

    const size_t index = static_cast<size_t>(e);
    return EnumNamesHighPrecisionMapGPSStatus()[index];
}

enum HighPrecisionMapPointStatus : int32_t
{
    HighPrecisionMapPointStatus_HP_POINT_NOT_VALID = 0,
    HighPrecisionMapPointStatus_HP_ENTER = 1,
    HighPrecisionMapPointStatus_HP_EXIT = 2,
    HighPrecisionMapPointStatus_MIN = HighPrecisionMapPointStatus_HP_POINT_NOT_VALID,
    HighPrecisionMapPointStatus_MAX = HighPrecisionMapPointStatus_HP_EXIT
};

inline const HighPrecisionMapPointStatus (&EnumValuesHighPrecisionMapPointStatus())[3]
{
    static const HighPrecisionMapPointStatus values[] = {
        HighPrecisionMapPointStatus_HP_POINT_NOT_VALID,
        HighPrecisionMapPointStatus_HP_ENTER,
        HighPrecisionMapPointStatus_HP_EXIT
    };
    return values;
}

inline const char* const* EnumNamesHighPrecisionMapPointStatus()
{
    static const char* const names[4] =
    {
        "HP_POINT_NOT_VALID",
        "HP_ENTER",
        "HP_EXIT",
        nullptr
    };
    return names;
}

inline const char* EnumNameHighPrecisionMapPointStatus(HighPrecisionMapPointStatus e)
{
    if (::flatbuffers::IsOutRange(e, HighPrecisionMapPointStatus_HP_POINT_NOT_VALID, HighPrecisionMapPointStatus_HP_EXIT)) return "";

    const size_t index = static_cast<size_t>(e);
    return EnumNamesHighPrecisionMapPointStatus()[index];
}

enum NowLocationHPMapStatusConstant : int32_t
{
    NowLocationHPMapStatusConstant_N_HP_AREA_NOT_VALID = 0,
    NowLocationHPMapStatusConstant_N_IN_HP_MAP_AREA = 1,
    NowLocationHPMapStatusConstant_N_NOT_IN_HP_MAP_AREA = 2,
    NowLocationHPMapStatusConstant_MIN = NowLocationHPMapStatusConstant_N_HP_AREA_NOT_VALID,
    NowLocationHPMapStatusConstant_MAX = NowLocationHPMapStatusConstant_N_NOT_IN_HP_MAP_AREA
};

inline const NowLocationHPMapStatusConstant (&EnumValuesNowLocationHPMapStatusConstant())[3]
{
    static const NowLocationHPMapStatusConstant values[] = {
        NowLocationHPMapStatusConstant_N_HP_AREA_NOT_VALID,
        NowLocationHPMapStatusConstant_N_IN_HP_MAP_AREA,
        NowLocationHPMapStatusConstant_N_NOT_IN_HP_MAP_AREA
    };
    return values;
}

inline const char* const* EnumNamesNowLocationHPMapStatusConstant()
{
    static const char* const names[4] =
    {
        "N_HP_AREA_NOT_VALID",
        "N_IN_HP_MAP_AREA",
        "N_NOT_IN_HP_MAP_AREA",
        nullptr
    };
    return names;
}

inline const char* EnumNameNowLocationHPMapStatusConstant(NowLocationHPMapStatusConstant e)
{
    if (::flatbuffers::IsOutRange(e, NowLocationHPMapStatusConstant_N_HP_AREA_NOT_VALID, NowLocationHPMapStatusConstant_N_NOT_IN_HP_MAP_AREA)) return "";

    const size_t index = static_cast<size_t>(e);
    return EnumNamesNowLocationHPMapStatusConstant()[index];
}

enum NopInfo : uint8_t
{
    NopInfo_NONE = 0,
    NopInfo_highPrecisionMapQueryRequest = 1,
    NopInfo_highPrecisionMapQueryResponse = 2,
    NopInfo_highPrecisionMapPointList = 3,
    NopInfo_nowLocationHPMapStatus = 4,
    NopInfo_highPrecisionQueryMapEnterRequest = 5,
    NopInfo_highPrecisionQueryMapEnterResponse = 6,
    NopInfo_MIN = NopInfo_NONE,
    NopInfo_MAX = NopInfo_highPrecisionQueryMapEnterResponse
};

inline const NopInfo (&EnumValuesNopInfo())[7]
{
    static const NopInfo values[] = {
        NopInfo_NONE,
        NopInfo_highPrecisionMapQueryRequest,
        NopInfo_highPrecisionMapQueryResponse,
        NopInfo_highPrecisionMapPointList,
        NopInfo_nowLocationHPMapStatus,
        NopInfo_highPrecisionQueryMapEnterRequest,
        NopInfo_highPrecisionQueryMapEnterResponse
    };
    return values;
}

inline const char* const* EnumNamesNopInfo()
{
    static const char* const names[8] =
    {
        "NONE",
        "highPrecisionMapQueryRequest",
        "highPrecisionMapQueryResponse",
        "highPrecisionMapPointList",
        "nowLocationHPMapStatus",
        "highPrecisionQueryMapEnterRequest",
        "highPrecisionQueryMapEnterResponse",
        nullptr
    };
    return names;
}

inline const char* EnumNameNopInfo(NopInfo e)
{
    if (::flatbuffers::IsOutRange(e, NopInfo_NONE, NopInfo_highPrecisionQueryMapEnterResponse)) return "";

    const size_t index = static_cast<size_t>(e);
    return EnumNamesNopInfo()[index];
}

bool VerifyNopInfo(::flatbuffers::Verifier& verifier, const void* obj, NopInfo type);
bool VerifyNopInfoVector(::flatbuffers::Verifier& verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>>* values, const ::flatbuffers::Vector<uint8_t>* types);

enum FourDCruisePointsData : uint8_t
{
    FourDCruisePointsData_NONE = 0,
    FourDCruisePointsData_road_name_request = 1,
    FourDCruisePointsData_route_request = 2,
    FourDCruisePointsData_MIN = FourDCruisePointsData_NONE,
    FourDCruisePointsData_MAX = FourDCruisePointsData_route_request
};

inline const FourDCruisePointsData (&EnumValuesFourDCruisePointsData())[3]
{
    static const FourDCruisePointsData values[] = {
        FourDCruisePointsData_NONE,
        FourDCruisePointsData_road_name_request,
        FourDCruisePointsData_route_request
    };
    return values;
}

inline const char* const* EnumNamesFourDCruisePointsData()
{
    static const char* const names[4] =
    {
        "NONE",
        "road_name_request",
        "route_request",
        nullptr
    };
    return names;
}

inline const char* EnumNameFourDCruisePointsData(FourDCruisePointsData e)
{
    if (::flatbuffers::IsOutRange(e, FourDCruisePointsData_NONE, FourDCruisePointsData_route_request)) return "";

    const size_t index = static_cast<size_t>(e);
    return EnumNamesFourDCruisePointsData()[index];
}

template<typename T> struct FourDCruisePointsDataTraits
{
    static const FourDCruisePointsData enum_value = FourDCruisePointsData_NONE;
};

template<> struct FourDCruisePointsDataTraits<com::nio::map::adas::flat::SearchByRoadNameRequest>
{
    static const FourDCruisePointsData enum_value = FourDCruisePointsData_road_name_request;
};

template<> struct FourDCruisePointsDataTraits<com::nio::map::adas::flat::SearchByRouteRequest>
{
    static const FourDCruisePointsData enum_value = FourDCruisePointsData_route_request;
};

bool VerifyFourDCruisePointsData(::flatbuffers::Verifier& verifier, const void* obj, FourDCruisePointsData type);
bool VerifyFourDCruisePointsDataVector(::flatbuffers::Verifier& verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>>* values, const ::flatbuffers::Vector<uint8_t>* types);

enum RoadConditionType : int32_t
{
    RoadConditionType_RC_TYPE_INVALID = 0,
    RoadConditionType_RC_TYPE_STRAIGHT_WAY = 1,
    RoadConditionType_RC_TYPE_SLIGHT_CONGESTION = 2,
    RoadConditionType_RC_TYPE_CONGESTION = 3,
    RoadConditionType_RC_TYPE_HEAVY_CONGESTION = 4,
    RoadConditionType_MIN = RoadConditionType_RC_TYPE_INVALID,
    RoadConditionType_MAX = RoadConditionType_RC_TYPE_HEAVY_CONGESTION
};

inline const RoadConditionType (&EnumValuesRoadConditionType())[5]
{
    static const RoadConditionType values[] = {
        RoadConditionType_RC_TYPE_INVALID,
        RoadConditionType_RC_TYPE_STRAIGHT_WAY,
        RoadConditionType_RC_TYPE_SLIGHT_CONGESTION,
        RoadConditionType_RC_TYPE_CONGESTION,
        RoadConditionType_RC_TYPE_HEAVY_CONGESTION
    };
    return values;
}

inline const char* const* EnumNamesRoadConditionType()
{
    static const char* const names[6] =
    {
        "RC_TYPE_INVALID",
        "RC_TYPE_STRAIGHT_WAY",
        "RC_TYPE_SLIGHT_CONGESTION",
        "RC_TYPE_CONGESTION",
        "RC_TYPE_HEAVY_CONGESTION",
        nullptr
    };
    return names;
}

inline const char* EnumNameRoadConditionType(RoadConditionType e)
{
    if (::flatbuffers::IsOutRange(e, RoadConditionType_RC_TYPE_INVALID, RoadConditionType_RC_TYPE_HEAVY_CONGESTION)) return "";

    const size_t index = static_cast<size_t>(e);
    return EnumNamesRoadConditionType()[index];
}

enum HdRoutesEventType : int32_t
{
    HdRoutesEventType_AO_DEGRADE = 0,
    HdRoutesEventType_AD_LANESEG_DEGRADE = 1,
    HdRoutesEventType_ORDINARY_DISPLAY = 2,
    HdRoutesEventType_ROUTING_AFTER_REBOOT = 9,
    HdRoutesEventType_OTHER = 10,
    HdRoutesEventType_MIN = HdRoutesEventType_AO_DEGRADE,
    HdRoutesEventType_MAX = HdRoutesEventType_OTHER
};

inline const HdRoutesEventType (&EnumValuesHdRoutesEventType())[5]
{
    static const HdRoutesEventType values[] = {
        HdRoutesEventType_AO_DEGRADE,
        HdRoutesEventType_AD_LANESEG_DEGRADE,
        HdRoutesEventType_ORDINARY_DISPLAY,
        HdRoutesEventType_ROUTING_AFTER_REBOOT,
        HdRoutesEventType_OTHER
    };
    return values;
}

inline const char* const* EnumNamesHdRoutesEventType()
{
    static const char* const names[12] =
    {
        "AO_DEGRADE",
        "AD_LANESEG_DEGRADE",
        "ORDINARY_DISPLAY",
        "",
        "",
        "",
        "",
        "",
        "",
        "ROUTING_AFTER_REBOOT",
        "OTHER",
        nullptr
    };
    return names;
}

inline const char* EnumNameHdRoutesEventType(HdRoutesEventType e)
{
    if (::flatbuffers::IsOutRange(e, HdRoutesEventType_AO_DEGRADE, HdRoutesEventType_OTHER)) return "";

    const size_t index = static_cast<size_t>(e);
    return EnumNamesHdRoutesEventType()[index];
}

enum HdRoutesEventID : int32_t
{
    HdRoutesEventID_APPROACHING_SA_EVNET = 0,
    HdRoutesEventID_FORMWAY_CHANGE_EVENT = 1,
    HdRoutesEventID_PSP_TAKE_OVER_EVNET = 2,
    HdRoutesEventID_PSP_QUIT_EVENT = 3,
    HdRoutesEventID_HD_SEGMENT_START = 4,
    HdRoutesEventID_HD_SEGMENT_END = 5,
    HdRoutesEventID_TOLL_STATION_ENTRY = 6,
    HdRoutesEventID_TOLL_STATION_EXIT = 7,
    HdRoutesEventID_AO_DEGRADE_ENTRY = 8,
    HdRoutesEventID_AO_DEGRADE_EXIT = 9,
    HdRoutesEventID_AD_LANESEG_DEGRADE_ENTRY = 10,
    HdRoutesEventID_AD_LANESEG_DEGRADE_EXIT = 11,
    HdRoutesEventID_CHECK_POINT_ENTRY = 12,
    HdRoutesEventID_CHECK_POINT_EXIT = 13,
    HdRoutesEventID_OTHER = 200,
    HdRoutesEventID_MIN = HdRoutesEventID_APPROACHING_SA_EVNET,
    HdRoutesEventID_MAX = HdRoutesEventID_OTHER
};

inline const HdRoutesEventID (&EnumValuesHdRoutesEventID())[15]
{
    static const HdRoutesEventID values[] = {
        HdRoutesEventID_APPROACHING_SA_EVNET,
        HdRoutesEventID_FORMWAY_CHANGE_EVENT,
        HdRoutesEventID_PSP_TAKE_OVER_EVNET,
        HdRoutesEventID_PSP_QUIT_EVENT,
        HdRoutesEventID_HD_SEGMENT_START,
        HdRoutesEventID_HD_SEGMENT_END,
        HdRoutesEventID_TOLL_STATION_ENTRY,
        HdRoutesEventID_TOLL_STATION_EXIT,
        HdRoutesEventID_AO_DEGRADE_ENTRY,
        HdRoutesEventID_AO_DEGRADE_EXIT,
        HdRoutesEventID_AD_LANESEG_DEGRADE_ENTRY,
        HdRoutesEventID_AD_LANESEG_DEGRADE_EXIT,
        HdRoutesEventID_CHECK_POINT_ENTRY,
        HdRoutesEventID_CHECK_POINT_EXIT,
        HdRoutesEventID_OTHER
    };
    return values;
}

inline const char* EnumNameHdRoutesEventID(HdRoutesEventID e)
{
    switch (e)
    {
        case HdRoutesEventID_APPROACHING_SA_EVNET:
            return "APPROACHING_SA_EVNET";

        case HdRoutesEventID_FORMWAY_CHANGE_EVENT:
            return "FORMWAY_CHANGE_EVENT";

        case HdRoutesEventID_PSP_TAKE_OVER_EVNET:
            return "PSP_TAKE_OVER_EVNET";

        case HdRoutesEventID_PSP_QUIT_EVENT:
            return "PSP_QUIT_EVENT";

        case HdRoutesEventID_HD_SEGMENT_START:
            return "HD_SEGMENT_START";

        case HdRoutesEventID_HD_SEGMENT_END:
            return "HD_SEGMENT_END";

        case HdRoutesEventID_TOLL_STATION_ENTRY:
            return "TOLL_STATION_ENTRY";

        case HdRoutesEventID_TOLL_STATION_EXIT:
            return "TOLL_STATION_EXIT";

        case HdRoutesEventID_AO_DEGRADE_ENTRY:
            return "AO_DEGRADE_ENTRY";

        case HdRoutesEventID_AO_DEGRADE_EXIT:
            return "AO_DEGRADE_EXIT";

        case HdRoutesEventID_AD_LANESEG_DEGRADE_ENTRY:
            return "AD_LANESEG_DEGRADE_ENTRY";

        case HdRoutesEventID_AD_LANESEG_DEGRADE_EXIT:
            return "AD_LANESEG_DEGRADE_EXIT";

        case HdRoutesEventID_CHECK_POINT_ENTRY:
            return "CHECK_POINT_ENTRY";

        case HdRoutesEventID_CHECK_POINT_EXIT:
            return "CHECK_POINT_EXIT";

        case HdRoutesEventID_OTHER:
            return "OTHER";

        default:
            return "";
    }
}

enum SDMapInfo : uint8_t
{
    SDMapInfo_NONE = 0,
    SDMapInfo_nodeInfo = 1,
    SDMapInfo_adasInfo = 2,
    SDMapInfo_nopInfo = 3,
    SDMapInfo_mapLoc = 4,
    SDMapInfo_routeMatchRequest = 5,
    SDMapInfo_routeMatchResponse = 6,
    SDMapInfo_nadInfo = 7,
    SDMapInfo_roadConditionInfo = 8,
    SDMapInfo_resetPredictiveTree = 9,
    SDMapInfo_hdRoutesEvents = 10,
    SDMapInfo_bumpyPois = 11,
    SDMapInfo_trafficLightCountdown = 12,
    SDMapInfo_fourDCruisePointsRequest = 13,
    SDMapInfo_MIN = SDMapInfo_NONE,
    SDMapInfo_MAX = SDMapInfo_fourDCruisePointsRequest
};

inline const SDMapInfo (&EnumValuesSDMapInfo())[14]
{
    static const SDMapInfo values[] = {
        SDMapInfo_NONE,
        SDMapInfo_nodeInfo,
        SDMapInfo_adasInfo,
        SDMapInfo_nopInfo,
        SDMapInfo_mapLoc,
        SDMapInfo_routeMatchRequest,
        SDMapInfo_routeMatchResponse,
        SDMapInfo_nadInfo,
        SDMapInfo_roadConditionInfo,
        SDMapInfo_resetPredictiveTree,
        SDMapInfo_hdRoutesEvents,
        SDMapInfo_bumpyPois,
        SDMapInfo_trafficLightCountdown,
        SDMapInfo_fourDCruisePointsRequest
    };
    return values;
}

inline const char* const* EnumNamesSDMapInfo()
{
    static const char* const names[15] =
    {
        "NONE",
        "nodeInfo",
        "adasInfo",
        "nopInfo",
        "mapLoc",
        "routeMatchRequest",
        "routeMatchResponse",
        "nadInfo",
        "roadConditionInfo",
        "resetPredictiveTree",
        "hdRoutesEvents",
        "bumpyPois",
        "trafficLightCountdown",
        "fourDCruisePointsRequest",
        nullptr
    };
    return names;
}

inline const char* EnumNameSDMapInfo(SDMapInfo e)
{
    if (::flatbuffers::IsOutRange(e, SDMapInfo_NONE, SDMapInfo_fourDCruisePointsRequest)) return "";

    const size_t index = static_cast<size_t>(e);
    return EnumNamesSDMapInfo()[index];
}

template<typename T> struct SDMapInfoTraits
{
    static const SDMapInfo enum_value = SDMapInfo_NONE;
};

template<> struct SDMapInfoTraits<com::nio::map::adas::flat::NodeInfoData>
{
    static const SDMapInfo enum_value = SDMapInfo_nodeInfo;
};

template<> struct SDMapInfoTraits<com::nio::map::adas::flat::AdasInfoData>
{
    static const SDMapInfo enum_value = SDMapInfo_adasInfo;
};

template<> struct SDMapInfoTraits<com::nio::map::adas::flat::NopInfoData>
{
    static const SDMapInfo enum_value = SDMapInfo_nopInfo;
};

template<> struct SDMapInfoTraits<com::nio::map::adas::flat::NavMapLocVersion2>
{
    static const SDMapInfo enum_value = SDMapInfo_mapLoc;
};

template<> struct SDMapInfoTraits<com::nio::map::adas::flat::RouteMatchRequest>
{
    static const SDMapInfo enum_value = SDMapInfo_routeMatchRequest;
};

template<> struct SDMapInfoTraits<com::nio::map::adas::flat::RouteMatchResponse>
{
    static const SDMapInfo enum_value = SDMapInfo_routeMatchResponse;
};

template<> struct SDMapInfoTraits<com::nio::map::adas::flat::NADInfo>
{
    static const SDMapInfo enum_value = SDMapInfo_nadInfo;
};

template<> struct SDMapInfoTraits<com::nio::map::adas::flat::RoadConditionInfo>
{
    static const SDMapInfo enum_value = SDMapInfo_roadConditionInfo;
};

template<> struct SDMapInfoTraits<com::nio::map::adas::flat::ResetPredictiveTree>
{
    static const SDMapInfo enum_value = SDMapInfo_resetPredictiveTree;
};

template<> struct SDMapInfoTraits<com::nio::map::adas::flat::HDRoutesEvents>
{
    static const SDMapInfo enum_value = SDMapInfo_hdRoutesEvents;
};

template<> struct SDMapInfoTraits<com::nio::map::adas::flat::BumpyPoisInfo>
{
    static const SDMapInfo enum_value = SDMapInfo_bumpyPois;
};

template<> struct SDMapInfoTraits<com::nio::map::adas::flat::TrafficLightCountdownList>
{
    static const SDMapInfo enum_value = SDMapInfo_trafficLightCountdown;
};

template<> struct SDMapInfoTraits<com::nio::map::adas::flat::FourDCruisePointsRequest>
{
    static const SDMapInfo enum_value = SDMapInfo_fourDCruisePointsRequest;
};

bool VerifySDMapInfo(::flatbuffers::Verifier& verifier, const void* obj, SDMapInfo type);
bool VerifySDMapInfoVector(::flatbuffers::Verifier& verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>>* values, const ::flatbuffers::Vector<uint8_t>* types);

struct TrafficSign FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef TrafficSignBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_SIGN_TYPE = 4,
        VT_VALUE = 6,
        VT_LANE = 8,
        VT_VEHICLE_SPECIFIC = 10,
        VT_TIME_SPECIFIC = 12,
        VT_CONFITION = 14,
        VT_SIGN_LOCATION = 16,
        VT_RESERVED = 18
    };
    uint32_t sign_type() const
    {
        return GetField<uint32_t>(VT_SIGN_TYPE, 0);
    }
    uint32_t value() const
    {
        return GetField<uint32_t>(VT_VALUE, 0);
    }
    uint32_t lane() const
    {
        return GetField<uint32_t>(VT_LANE, 0);
    }
    uint32_t vehicle_specific() const
    {
        return GetField<uint32_t>(VT_VEHICLE_SPECIFIC, 0);
    }
    uint32_t time_specific() const
    {
        return GetField<uint32_t>(VT_TIME_SPECIFIC, 0);
    }
    uint32_t confition() const
    {
        return GetField<uint32_t>(VT_CONFITION, 0);
    }
    uint32_t sign_location() const
    {
        return GetField<uint32_t>(VT_SIGN_LOCATION, 0);
    }
    uint32_t reserved() const
    {
        return GetField<uint32_t>(VT_RESERVED, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<uint32_t>(verifier, VT_SIGN_TYPE, 4) &&
               VerifyField<uint32_t>(verifier, VT_VALUE, 4) &&
               VerifyField<uint32_t>(verifier, VT_LANE, 4) &&
               VerifyField<uint32_t>(verifier, VT_VEHICLE_SPECIFIC, 4) &&
               VerifyField<uint32_t>(verifier, VT_TIME_SPECIFIC, 4) &&
               VerifyField<uint32_t>(verifier, VT_CONFITION, 4) &&
               VerifyField<uint32_t>(verifier, VT_SIGN_LOCATION, 4) &&
               VerifyField<uint32_t>(verifier, VT_RESERVED, 4) &&
               verifier.EndTable();
    }
};

struct TrafficSignBuilder
{
    typedef TrafficSign Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_sign_type(uint32_t sign_type)
    {
        fbb_.AddElement<uint32_t>(TrafficSign::VT_SIGN_TYPE, sign_type, 0);
    }
    void add_value(uint32_t value)
    {
        fbb_.AddElement<uint32_t>(TrafficSign::VT_VALUE, value, 0);
    }
    void add_lane(uint32_t lane)
    {
        fbb_.AddElement<uint32_t>(TrafficSign::VT_LANE, lane, 0);
    }
    void add_vehicle_specific(uint32_t vehicle_specific)
    {
        fbb_.AddElement<uint32_t>(TrafficSign::VT_VEHICLE_SPECIFIC, vehicle_specific, 0);
    }
    void add_time_specific(uint32_t time_specific)
    {
        fbb_.AddElement<uint32_t>(TrafficSign::VT_TIME_SPECIFIC, time_specific, 0);
    }
    void add_confition(uint32_t confition)
    {
        fbb_.AddElement<uint32_t>(TrafficSign::VT_CONFITION, confition, 0);
    }
    void add_sign_location(uint32_t sign_location)
    {
        fbb_.AddElement<uint32_t>(TrafficSign::VT_SIGN_LOCATION, sign_location, 0);
    }
    void add_reserved(uint32_t reserved)
    {
        fbb_.AddElement<uint32_t>(TrafficSign::VT_RESERVED, reserved, 0);
    }
    explicit TrafficSignBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<TrafficSign> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<TrafficSign>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<TrafficSign> CreateTrafficSign(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    uint32_t sign_type = 0,
    uint32_t value = 0,
    uint32_t lane = 0,
    uint32_t vehicle_specific = 0,
    uint32_t time_specific = 0,
    uint32_t confition = 0,
    uint32_t sign_location = 0,
    uint32_t reserved = 0)
{
    TrafficSignBuilder builder_(_fbb);
    builder_.add_reserved(reserved);
    builder_.add_sign_location(sign_location);
    builder_.add_confition(confition);
    builder_.add_time_specific(time_specific);
    builder_.add_vehicle_specific(vehicle_specific);
    builder_.add_lane(lane);
    builder_.add_value(value);
    builder_.add_sign_type(sign_type);
    return builder_.Finish();
}

struct Position FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef PositionBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_CUR_OFFSET = 4,
        VT_CYC_CNT = 6,
        VT_PATH_IDX = 8,
        VT_IDX = 10,
        VT_POS_PROBB = 12,
        VT_AGE = 14,
        VT_RECALC_STATUS = 16,
        VT_POS_CONFDC = 18,
        VT_CUR_LANE = 20,
        VT_SPD = 22,
        VT_REL_HEAD = 24,
        VT_RESERVED = 26
    };
    uint32_t cur_offset() const
    {
        return GetField<uint32_t>(VT_CUR_OFFSET, 0);
    }
    uint32_t cyc_cnt() const
    {
        return GetField<uint32_t>(VT_CYC_CNT, 0);
    }
    uint32_t path_idx() const
    {
        return GetField<uint32_t>(VT_PATH_IDX, 0);
    }
    uint32_t idx() const
    {
        return GetField<uint32_t>(VT_IDX, 0);
    }
    uint32_t pos_probb() const
    {
        return GetField<uint32_t>(VT_POS_PROBB, 0);
    }
    uint32_t age() const
    {
        return GetField<uint32_t>(VT_AGE, 0);
    }
    uint32_t recalc_status() const
    {
        return GetField<uint32_t>(VT_RECALC_STATUS, 0);
    }
    uint32_t pos_confdc() const
    {
        return GetField<uint32_t>(VT_POS_CONFDC, 0);
    }
    uint32_t cur_lane() const
    {
        return GetField<uint32_t>(VT_CUR_LANE, 0);
    }
    uint32_t spd() const
    {
        return GetField<uint32_t>(VT_SPD, 0);
    }
    uint32_t rel_head() const
    {
        return GetField<uint32_t>(VT_REL_HEAD, 0);
    }
    uint32_t reserved() const
    {
        return GetField<uint32_t>(VT_RESERVED, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<uint32_t>(verifier, VT_CUR_OFFSET, 4) &&
               VerifyField<uint32_t>(verifier, VT_CYC_CNT, 4) &&
               VerifyField<uint32_t>(verifier, VT_PATH_IDX, 4) &&
               VerifyField<uint32_t>(verifier, VT_IDX, 4) &&
               VerifyField<uint32_t>(verifier, VT_POS_PROBB, 4) &&
               VerifyField<uint32_t>(verifier, VT_AGE, 4) &&
               VerifyField<uint32_t>(verifier, VT_RECALC_STATUS, 4) &&
               VerifyField<uint32_t>(verifier, VT_POS_CONFDC, 4) &&
               VerifyField<uint32_t>(verifier, VT_CUR_LANE, 4) &&
               VerifyField<uint32_t>(verifier, VT_SPD, 4) &&
               VerifyField<uint32_t>(verifier, VT_REL_HEAD, 4) &&
               VerifyField<uint32_t>(verifier, VT_RESERVED, 4) &&
               verifier.EndTable();
    }
};

struct PositionBuilder
{
    typedef Position Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_cur_offset(uint32_t cur_offset)
    {
        fbb_.AddElement<uint32_t>(Position::VT_CUR_OFFSET, cur_offset, 0);
    }
    void add_cyc_cnt(uint32_t cyc_cnt)
    {
        fbb_.AddElement<uint32_t>(Position::VT_CYC_CNT, cyc_cnt, 0);
    }
    void add_path_idx(uint32_t path_idx)
    {
        fbb_.AddElement<uint32_t>(Position::VT_PATH_IDX, path_idx, 0);
    }
    void add_idx(uint32_t idx)
    {
        fbb_.AddElement<uint32_t>(Position::VT_IDX, idx, 0);
    }
    void add_pos_probb(uint32_t pos_probb)
    {
        fbb_.AddElement<uint32_t>(Position::VT_POS_PROBB, pos_probb, 0);
    }
    void add_age(uint32_t age)
    {
        fbb_.AddElement<uint32_t>(Position::VT_AGE, age, 0);
    }
    void add_recalc_status(uint32_t recalc_status)
    {
        fbb_.AddElement<uint32_t>(Position::VT_RECALC_STATUS, recalc_status, 0);
    }
    void add_pos_confdc(uint32_t pos_confdc)
    {
        fbb_.AddElement<uint32_t>(Position::VT_POS_CONFDC, pos_confdc, 0);
    }
    void add_cur_lane(uint32_t cur_lane)
    {
        fbb_.AddElement<uint32_t>(Position::VT_CUR_LANE, cur_lane, 0);
    }
    void add_spd(uint32_t spd)
    {
        fbb_.AddElement<uint32_t>(Position::VT_SPD, spd, 0);
    }
    void add_rel_head(uint32_t rel_head)
    {
        fbb_.AddElement<uint32_t>(Position::VT_REL_HEAD, rel_head, 0);
    }
    void add_reserved(uint32_t reserved)
    {
        fbb_.AddElement<uint32_t>(Position::VT_RESERVED, reserved, 0);
    }
    explicit PositionBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<Position> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<Position>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<Position> CreatePosition(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    uint32_t cur_offset = 0,
    uint32_t cyc_cnt = 0,
    uint32_t path_idx = 0,
    uint32_t idx = 0,
    uint32_t pos_probb = 0,
    uint32_t age = 0,
    uint32_t recalc_status = 0,
    uint32_t pos_confdc = 0,
    uint32_t cur_lane = 0,
    uint32_t spd = 0,
    uint32_t rel_head = 0,
    uint32_t reserved = 0)
{
    PositionBuilder builder_(_fbb);
    builder_.add_reserved(reserved);
    builder_.add_rel_head(rel_head);
    builder_.add_spd(spd);
    builder_.add_cur_lane(cur_lane);
    builder_.add_pos_confdc(pos_confdc);
    builder_.add_recalc_status(recalc_status);
    builder_.add_age(age);
    builder_.add_pos_probb(pos_probb);
    builder_.add_idx(idx);
    builder_.add_path_idx(path_idx);
    builder_.add_cyc_cnt(cyc_cnt);
    builder_.add_cur_offset(cur_offset);
    return builder_.Finish();
}

struct Segment FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef SegmentBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_OFFSET = 4,
        VT_CYC_CNT = 6,
        VT_PATH_IDX = 8,
        VT_TUNNEL = 10,
        VT_BRIDGE = 12,
        VT_BUILD_UP_AREA = 14,
        VT_RETR = 16,
        VT_UPDATE = 18,
        VT_REL_PROBB = 20,
        VT_FUNC_ROAD_CLASS = 22,
        VT_PART_OF_CALC_ROUTE = 24,
        VT_CMPLX_INSCT = 26,
        VT_FORM_OF_WAY = 28,
        VT_EFF_SPD_LMT = 30,
        VT_EFF_SPD_LMT_TYPE = 32,
        VT_RESERVED = 34,
        VT_DIVIDED_ROAD = 36,
        VT_NUM_OF_LANE_OPP_DIR = 38,
        VT_NUM_OF_LANE_DRV_DIR = 40
    };
    uint32_t offset() const
    {
        return GetField<uint32_t>(VT_OFFSET, 0);
    }
    uint32_t cyc_cnt() const
    {
        return GetField<uint32_t>(VT_CYC_CNT, 0);
    }
    uint32_t path_idx() const
    {
        return GetField<uint32_t>(VT_PATH_IDX, 0);
    }
    uint32_t tunnel() const
    {
        return GetField<uint32_t>(VT_TUNNEL, 0);
    }
    uint32_t bridge() const
    {
        return GetField<uint32_t>(VT_BRIDGE, 0);
    }
    uint32_t build_up_area() const
    {
        return GetField<uint32_t>(VT_BUILD_UP_AREA, 0);
    }
    uint32_t retr() const
    {
        return GetField<uint32_t>(VT_RETR, 0);
    }
    uint32_t update() const
    {
        return GetField<uint32_t>(VT_UPDATE, 0);
    }
    uint32_t rel_probb() const
    {
        return GetField<uint32_t>(VT_REL_PROBB, 0);
    }
    uint32_t func_road_class() const
    {
        return GetField<uint32_t>(VT_FUNC_ROAD_CLASS, 0);
    }
    uint32_t part_of_calc_route() const
    {
        return GetField<uint32_t>(VT_PART_OF_CALC_ROUTE, 0);
    }
    uint32_t cmplx_insct() const
    {
        return GetField<uint32_t>(VT_CMPLX_INSCT, 0);
    }
    uint32_t form_of_way() const
    {
        return GetField<uint32_t>(VT_FORM_OF_WAY, 0);
    }
    uint32_t eff_spd_lmt() const
    {
        return GetField<uint32_t>(VT_EFF_SPD_LMT, 0);
    }
    uint32_t eff_spd_lmt_type() const
    {
        return GetField<uint32_t>(VT_EFF_SPD_LMT_TYPE, 0);
    }
    uint32_t reserved() const
    {
        return GetField<uint32_t>(VT_RESERVED, 0);
    }
    uint32_t divided_road() const
    {
        return GetField<uint32_t>(VT_DIVIDED_ROAD, 0);
    }
    uint32_t num_of_lane_opp_dir() const
    {
        return GetField<uint32_t>(VT_NUM_OF_LANE_OPP_DIR, 0);
    }
    uint32_t num_of_lane_drv_dir() const
    {
        return GetField<uint32_t>(VT_NUM_OF_LANE_DRV_DIR, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<uint32_t>(verifier, VT_OFFSET, 4) &&
               VerifyField<uint32_t>(verifier, VT_CYC_CNT, 4) &&
               VerifyField<uint32_t>(verifier, VT_PATH_IDX, 4) &&
               VerifyField<uint32_t>(verifier, VT_TUNNEL, 4) &&
               VerifyField<uint32_t>(verifier, VT_BRIDGE, 4) &&
               VerifyField<uint32_t>(verifier, VT_BUILD_UP_AREA, 4) &&
               VerifyField<uint32_t>(verifier, VT_RETR, 4) &&
               VerifyField<uint32_t>(verifier, VT_UPDATE, 4) &&
               VerifyField<uint32_t>(verifier, VT_REL_PROBB, 4) &&
               VerifyField<uint32_t>(verifier, VT_FUNC_ROAD_CLASS, 4) &&
               VerifyField<uint32_t>(verifier, VT_PART_OF_CALC_ROUTE, 4) &&
               VerifyField<uint32_t>(verifier, VT_CMPLX_INSCT, 4) &&
               VerifyField<uint32_t>(verifier, VT_FORM_OF_WAY, 4) &&
               VerifyField<uint32_t>(verifier, VT_EFF_SPD_LMT, 4) &&
               VerifyField<uint32_t>(verifier, VT_EFF_SPD_LMT_TYPE, 4) &&
               VerifyField<uint32_t>(verifier, VT_RESERVED, 4) &&
               VerifyField<uint32_t>(verifier, VT_DIVIDED_ROAD, 4) &&
               VerifyField<uint32_t>(verifier, VT_NUM_OF_LANE_OPP_DIR, 4) &&
               VerifyField<uint32_t>(verifier, VT_NUM_OF_LANE_DRV_DIR, 4) &&
               verifier.EndTable();
    }
};

struct SegmentBuilder
{
    typedef Segment Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_offset(uint32_t offset)
    {
        fbb_.AddElement<uint32_t>(Segment::VT_OFFSET, offset, 0);
    }
    void add_cyc_cnt(uint32_t cyc_cnt)
    {
        fbb_.AddElement<uint32_t>(Segment::VT_CYC_CNT, cyc_cnt, 0);
    }
    void add_path_idx(uint32_t path_idx)
    {
        fbb_.AddElement<uint32_t>(Segment::VT_PATH_IDX, path_idx, 0);
    }
    void add_tunnel(uint32_t tunnel)
    {
        fbb_.AddElement<uint32_t>(Segment::VT_TUNNEL, tunnel, 0);
    }
    void add_bridge(uint32_t bridge)
    {
        fbb_.AddElement<uint32_t>(Segment::VT_BRIDGE, bridge, 0);
    }
    void add_build_up_area(uint32_t build_up_area)
    {
        fbb_.AddElement<uint32_t>(Segment::VT_BUILD_UP_AREA, build_up_area, 0);
    }
    void add_retr(uint32_t retr)
    {
        fbb_.AddElement<uint32_t>(Segment::VT_RETR, retr, 0);
    }
    void add_update(uint32_t update)
    {
        fbb_.AddElement<uint32_t>(Segment::VT_UPDATE, update, 0);
    }
    void add_rel_probb(uint32_t rel_probb)
    {
        fbb_.AddElement<uint32_t>(Segment::VT_REL_PROBB, rel_probb, 0);
    }
    void add_func_road_class(uint32_t func_road_class)
    {
        fbb_.AddElement<uint32_t>(Segment::VT_FUNC_ROAD_CLASS, func_road_class, 0);
    }
    void add_part_of_calc_route(uint32_t part_of_calc_route)
    {
        fbb_.AddElement<uint32_t>(Segment::VT_PART_OF_CALC_ROUTE, part_of_calc_route, 0);
    }
    void add_cmplx_insct(uint32_t cmplx_insct)
    {
        fbb_.AddElement<uint32_t>(Segment::VT_CMPLX_INSCT, cmplx_insct, 0);
    }
    void add_form_of_way(uint32_t form_of_way)
    {
        fbb_.AddElement<uint32_t>(Segment::VT_FORM_OF_WAY, form_of_way, 0);
    }
    void add_eff_spd_lmt(uint32_t eff_spd_lmt)
    {
        fbb_.AddElement<uint32_t>(Segment::VT_EFF_SPD_LMT, eff_spd_lmt, 0);
    }
    void add_eff_spd_lmt_type(uint32_t eff_spd_lmt_type)
    {
        fbb_.AddElement<uint32_t>(Segment::VT_EFF_SPD_LMT_TYPE, eff_spd_lmt_type, 0);
    }
    void add_reserved(uint32_t reserved)
    {
        fbb_.AddElement<uint32_t>(Segment::VT_RESERVED, reserved, 0);
    }
    void add_divided_road(uint32_t divided_road)
    {
        fbb_.AddElement<uint32_t>(Segment::VT_DIVIDED_ROAD, divided_road, 0);
    }
    void add_num_of_lane_opp_dir(uint32_t num_of_lane_opp_dir)
    {
        fbb_.AddElement<uint32_t>(Segment::VT_NUM_OF_LANE_OPP_DIR, num_of_lane_opp_dir, 0);
    }
    void add_num_of_lane_drv_dir(uint32_t num_of_lane_drv_dir)
    {
        fbb_.AddElement<uint32_t>(Segment::VT_NUM_OF_LANE_DRV_DIR, num_of_lane_drv_dir, 0);
    }
    explicit SegmentBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<Segment> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<Segment>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<Segment> CreateSegment(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    uint32_t offset = 0,
    uint32_t cyc_cnt = 0,
    uint32_t path_idx = 0,
    uint32_t tunnel = 0,
    uint32_t bridge = 0,
    uint32_t build_up_area = 0,
    uint32_t retr = 0,
    uint32_t update = 0,
    uint32_t rel_probb = 0,
    uint32_t func_road_class = 0,
    uint32_t part_of_calc_route = 0,
    uint32_t cmplx_insct = 0,
    uint32_t form_of_way = 0,
    uint32_t eff_spd_lmt = 0,
    uint32_t eff_spd_lmt_type = 0,
    uint32_t reserved = 0,
    uint32_t divided_road = 0,
    uint32_t num_of_lane_opp_dir = 0,
    uint32_t num_of_lane_drv_dir = 0)
{
    SegmentBuilder builder_(_fbb);
    builder_.add_num_of_lane_drv_dir(num_of_lane_drv_dir);
    builder_.add_num_of_lane_opp_dir(num_of_lane_opp_dir);
    builder_.add_divided_road(divided_road);
    builder_.add_reserved(reserved);
    builder_.add_eff_spd_lmt_type(eff_spd_lmt_type);
    builder_.add_eff_spd_lmt(eff_spd_lmt);
    builder_.add_form_of_way(form_of_way);
    builder_.add_cmplx_insct(cmplx_insct);
    builder_.add_part_of_calc_route(part_of_calc_route);
    builder_.add_func_road_class(func_road_class);
    builder_.add_rel_probb(rel_probb);
    builder_.add_update(update);
    builder_.add_retr(retr);
    builder_.add_build_up_area(build_up_area);
    builder_.add_bridge(bridge);
    builder_.add_tunnel(tunnel);
    builder_.add_path_idx(path_idx);
    builder_.add_cyc_cnt(cyc_cnt);
    builder_.add_offset(offset);
    return builder_.Finish();
}

struct Stub FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef StubBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_OFFSET = 4,
        VT_CYC_CNT = 6,
        VT_PATH_IDX = 8,
        VT_SUB_PATH_IDX = 10,
        VT_RETR = 12,
        VT_UPDATE = 14,
        VT_REL_PROBB = 16,
        VT_FUNC_ROAD_CLASS = 18,
        VT_PART_OF_CALC_ROUTE = 20,
        VT_CMPLX_INSCT = 22,
        VT_FORM_OF_WAY = 24,
        VT_TURN_ANGL = 26,
        VT_LAST_STUB = 28,
        VT_RT_OF_WAY = 30,
        VT_NUM_OF_LANE_OPP_DIR = 32,
        VT_NUM_OF_LANE_DRV_DIR = 34
    };
    uint32_t offset() const
    {
        return GetField<uint32_t>(VT_OFFSET, 0);
    }
    uint32_t cyc_cnt() const
    {
        return GetField<uint32_t>(VT_CYC_CNT, 0);
    }
    uint32_t path_idx() const
    {
        return GetField<uint32_t>(VT_PATH_IDX, 0);
    }
    uint32_t sub_path_idx() const
    {
        return GetField<uint32_t>(VT_SUB_PATH_IDX, 0);
    }
    uint32_t retr() const
    {
        return GetField<uint32_t>(VT_RETR, 0);
    }
    uint32_t update() const
    {
        return GetField<uint32_t>(VT_UPDATE, 0);
    }
    uint32_t rel_probb() const
    {
        return GetField<uint32_t>(VT_REL_PROBB, 0);
    }
    uint32_t func_road_class() const
    {
        return GetField<uint32_t>(VT_FUNC_ROAD_CLASS, 0);
    }
    uint32_t part_of_calc_route() const
    {
        return GetField<uint32_t>(VT_PART_OF_CALC_ROUTE, 0);
    }
    uint32_t cmplx_insct() const
    {
        return GetField<uint32_t>(VT_CMPLX_INSCT, 0);
    }
    uint32_t form_of_way() const
    {
        return GetField<uint32_t>(VT_FORM_OF_WAY, 0);
    }
    uint32_t turn_angl() const
    {
        return GetField<uint32_t>(VT_TURN_ANGL, 0);
    }
    uint32_t last_stub() const
    {
        return GetField<uint32_t>(VT_LAST_STUB, 0);
    }
    uint32_t rt_of_way() const
    {
        return GetField<uint32_t>(VT_RT_OF_WAY, 0);
    }
    uint32_t num_of_lane_opp_dir() const
    {
        return GetField<uint32_t>(VT_NUM_OF_LANE_OPP_DIR, 0);
    }
    uint32_t num_of_lane_drv_dir() const
    {
        return GetField<uint32_t>(VT_NUM_OF_LANE_DRV_DIR, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<uint32_t>(verifier, VT_OFFSET, 4) &&
               VerifyField<uint32_t>(verifier, VT_CYC_CNT, 4) &&
               VerifyField<uint32_t>(verifier, VT_PATH_IDX, 4) &&
               VerifyField<uint32_t>(verifier, VT_SUB_PATH_IDX, 4) &&
               VerifyField<uint32_t>(verifier, VT_RETR, 4) &&
               VerifyField<uint32_t>(verifier, VT_UPDATE, 4) &&
               VerifyField<uint32_t>(verifier, VT_REL_PROBB, 4) &&
               VerifyField<uint32_t>(verifier, VT_FUNC_ROAD_CLASS, 4) &&
               VerifyField<uint32_t>(verifier, VT_PART_OF_CALC_ROUTE, 4) &&
               VerifyField<uint32_t>(verifier, VT_CMPLX_INSCT, 4) &&
               VerifyField<uint32_t>(verifier, VT_FORM_OF_WAY, 4) &&
               VerifyField<uint32_t>(verifier, VT_TURN_ANGL, 4) &&
               VerifyField<uint32_t>(verifier, VT_LAST_STUB, 4) &&
               VerifyField<uint32_t>(verifier, VT_RT_OF_WAY, 4) &&
               VerifyField<uint32_t>(verifier, VT_NUM_OF_LANE_OPP_DIR, 4) &&
               VerifyField<uint32_t>(verifier, VT_NUM_OF_LANE_DRV_DIR, 4) &&
               verifier.EndTable();
    }
};

struct StubBuilder
{
    typedef Stub Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_offset(uint32_t offset)
    {
        fbb_.AddElement<uint32_t>(Stub::VT_OFFSET, offset, 0);
    }
    void add_cyc_cnt(uint32_t cyc_cnt)
    {
        fbb_.AddElement<uint32_t>(Stub::VT_CYC_CNT, cyc_cnt, 0);
    }
    void add_path_idx(uint32_t path_idx)
    {
        fbb_.AddElement<uint32_t>(Stub::VT_PATH_IDX, path_idx, 0);
    }
    void add_sub_path_idx(uint32_t sub_path_idx)
    {
        fbb_.AddElement<uint32_t>(Stub::VT_SUB_PATH_IDX, sub_path_idx, 0);
    }
    void add_retr(uint32_t retr)
    {
        fbb_.AddElement<uint32_t>(Stub::VT_RETR, retr, 0);
    }
    void add_update(uint32_t update)
    {
        fbb_.AddElement<uint32_t>(Stub::VT_UPDATE, update, 0);
    }
    void add_rel_probb(uint32_t rel_probb)
    {
        fbb_.AddElement<uint32_t>(Stub::VT_REL_PROBB, rel_probb, 0);
    }
    void add_func_road_class(uint32_t func_road_class)
    {
        fbb_.AddElement<uint32_t>(Stub::VT_FUNC_ROAD_CLASS, func_road_class, 0);
    }
    void add_part_of_calc_route(uint32_t part_of_calc_route)
    {
        fbb_.AddElement<uint32_t>(Stub::VT_PART_OF_CALC_ROUTE, part_of_calc_route, 0);
    }
    void add_cmplx_insct(uint32_t cmplx_insct)
    {
        fbb_.AddElement<uint32_t>(Stub::VT_CMPLX_INSCT, cmplx_insct, 0);
    }
    void add_form_of_way(uint32_t form_of_way)
    {
        fbb_.AddElement<uint32_t>(Stub::VT_FORM_OF_WAY, form_of_way, 0);
    }
    void add_turn_angl(uint32_t turn_angl)
    {
        fbb_.AddElement<uint32_t>(Stub::VT_TURN_ANGL, turn_angl, 0);
    }
    void add_last_stub(uint32_t last_stub)
    {
        fbb_.AddElement<uint32_t>(Stub::VT_LAST_STUB, last_stub, 0);
    }
    void add_rt_of_way(uint32_t rt_of_way)
    {
        fbb_.AddElement<uint32_t>(Stub::VT_RT_OF_WAY, rt_of_way, 0);
    }
    void add_num_of_lane_opp_dir(uint32_t num_of_lane_opp_dir)
    {
        fbb_.AddElement<uint32_t>(Stub::VT_NUM_OF_LANE_OPP_DIR, num_of_lane_opp_dir, 0);
    }
    void add_num_of_lane_drv_dir(uint32_t num_of_lane_drv_dir)
    {
        fbb_.AddElement<uint32_t>(Stub::VT_NUM_OF_LANE_DRV_DIR, num_of_lane_drv_dir, 0);
    }
    explicit StubBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<Stub> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<Stub>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<Stub> CreateStub(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    uint32_t offset = 0,
    uint32_t cyc_cnt = 0,
    uint32_t path_idx = 0,
    uint32_t sub_path_idx = 0,
    uint32_t retr = 0,
    uint32_t update = 0,
    uint32_t rel_probb = 0,
    uint32_t func_road_class = 0,
    uint32_t part_of_calc_route = 0,
    uint32_t cmplx_insct = 0,
    uint32_t form_of_way = 0,
    uint32_t turn_angl = 0,
    uint32_t last_stub = 0,
    uint32_t rt_of_way = 0,
    uint32_t num_of_lane_opp_dir = 0,
    uint32_t num_of_lane_drv_dir = 0)
{
    StubBuilder builder_(_fbb);
    builder_.add_num_of_lane_drv_dir(num_of_lane_drv_dir);
    builder_.add_num_of_lane_opp_dir(num_of_lane_opp_dir);
    builder_.add_rt_of_way(rt_of_way);
    builder_.add_last_stub(last_stub);
    builder_.add_turn_angl(turn_angl);
    builder_.add_form_of_way(form_of_way);
    builder_.add_cmplx_insct(cmplx_insct);
    builder_.add_part_of_calc_route(part_of_calc_route);
    builder_.add_func_road_class(func_road_class);
    builder_.add_rel_probb(rel_probb);
    builder_.add_update(update);
    builder_.add_retr(retr);
    builder_.add_sub_path_idx(sub_path_idx);
    builder_.add_path_idx(path_idx);
    builder_.add_cyc_cnt(cyc_cnt);
    builder_.add_offset(offset);
    return builder_.Finish();
}

struct ProfileShort FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef ProfileShortBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_OFFSET = 4,
        VT_CYC_CNT = 6,
        VT_PATH_IDX = 8,
        VT_PROF_TYPE = 10,
        VT_CTRL_POINT = 12,
        VT_RETR = 14,
        VT_UPDATE = 16,
        VT_ACCURACY = 18,
        VT_DIST1 = 20,
        VT_VALUE0 = 22,
        VT_VALUE1 = 24
    };
    uint32_t offset() const
    {
        return GetField<uint32_t>(VT_OFFSET, 0);
    }
    uint32_t cyc_cnt() const
    {
        return GetField<uint32_t>(VT_CYC_CNT, 0);
    }
    uint32_t path_idx() const
    {
        return GetField<uint32_t>(VT_PATH_IDX, 0);
    }
    uint32_t prof_type() const
    {
        return GetField<uint32_t>(VT_PROF_TYPE, 0);
    }
    uint32_t ctrl_point() const
    {
        return GetField<uint32_t>(VT_CTRL_POINT, 0);
    }
    uint32_t retr() const
    {
        return GetField<uint32_t>(VT_RETR, 0);
    }
    uint32_t update() const
    {
        return GetField<uint32_t>(VT_UPDATE, 0);
    }
    uint32_t accuracy() const
    {
        return GetField<uint32_t>(VT_ACCURACY, 0);
    }
    uint32_t dist1() const
    {
        return GetField<uint32_t>(VT_DIST1, 0);
    }
    uint32_t value0() const
    {
        return GetField<uint32_t>(VT_VALUE0, 0);
    }
    uint32_t value1() const
    {
        return GetField<uint32_t>(VT_VALUE1, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<uint32_t>(verifier, VT_OFFSET, 4) &&
               VerifyField<uint32_t>(verifier, VT_CYC_CNT, 4) &&
               VerifyField<uint32_t>(verifier, VT_PATH_IDX, 4) &&
               VerifyField<uint32_t>(verifier, VT_PROF_TYPE, 4) &&
               VerifyField<uint32_t>(verifier, VT_CTRL_POINT, 4) &&
               VerifyField<uint32_t>(verifier, VT_RETR, 4) &&
               VerifyField<uint32_t>(verifier, VT_UPDATE, 4) &&
               VerifyField<uint32_t>(verifier, VT_ACCURACY, 4) &&
               VerifyField<uint32_t>(verifier, VT_DIST1, 4) &&
               VerifyField<uint32_t>(verifier, VT_VALUE0, 4) &&
               VerifyField<uint32_t>(verifier, VT_VALUE1, 4) &&
               verifier.EndTable();
    }
};

struct ProfileShortBuilder
{
    typedef ProfileShort Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_offset(uint32_t offset)
    {
        fbb_.AddElement<uint32_t>(ProfileShort::VT_OFFSET, offset, 0);
    }
    void add_cyc_cnt(uint32_t cyc_cnt)
    {
        fbb_.AddElement<uint32_t>(ProfileShort::VT_CYC_CNT, cyc_cnt, 0);
    }
    void add_path_idx(uint32_t path_idx)
    {
        fbb_.AddElement<uint32_t>(ProfileShort::VT_PATH_IDX, path_idx, 0);
    }
    void add_prof_type(uint32_t prof_type)
    {
        fbb_.AddElement<uint32_t>(ProfileShort::VT_PROF_TYPE, prof_type, 0);
    }
    void add_ctrl_point(uint32_t ctrl_point)
    {
        fbb_.AddElement<uint32_t>(ProfileShort::VT_CTRL_POINT, ctrl_point, 0);
    }
    void add_retr(uint32_t retr)
    {
        fbb_.AddElement<uint32_t>(ProfileShort::VT_RETR, retr, 0);
    }
    void add_update(uint32_t update)
    {
        fbb_.AddElement<uint32_t>(ProfileShort::VT_UPDATE, update, 0);
    }
    void add_accuracy(uint32_t accuracy)
    {
        fbb_.AddElement<uint32_t>(ProfileShort::VT_ACCURACY, accuracy, 0);
    }
    void add_dist1(uint32_t dist1)
    {
        fbb_.AddElement<uint32_t>(ProfileShort::VT_DIST1, dist1, 0);
    }
    void add_value0(uint32_t value0)
    {
        fbb_.AddElement<uint32_t>(ProfileShort::VT_VALUE0, value0, 0);
    }
    void add_value1(uint32_t value1)
    {
        fbb_.AddElement<uint32_t>(ProfileShort::VT_VALUE1, value1, 0);
    }
    explicit ProfileShortBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<ProfileShort> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<ProfileShort>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<ProfileShort> CreateProfileShort(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    uint32_t offset = 0,
    uint32_t cyc_cnt = 0,
    uint32_t path_idx = 0,
    uint32_t prof_type = 0,
    uint32_t ctrl_point = 0,
    uint32_t retr = 0,
    uint32_t update = 0,
    uint32_t accuracy = 0,
    uint32_t dist1 = 0,
    uint32_t value0 = 0,
    uint32_t value1 = 0)
{
    ProfileShortBuilder builder_(_fbb);
    builder_.add_value1(value1);
    builder_.add_value0(value0);
    builder_.add_dist1(dist1);
    builder_.add_accuracy(accuracy);
    builder_.add_update(update);
    builder_.add_retr(retr);
    builder_.add_ctrl_point(ctrl_point);
    builder_.add_prof_type(prof_type);
    builder_.add_path_idx(path_idx);
    builder_.add_cyc_cnt(cyc_cnt);
    builder_.add_offset(offset);
    return builder_.Finish();
}

struct ProfileLong FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef ProfileLongBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_OFFSET = 4,
        VT_CYC_CNT = 6,
        VT_PATH_IDX = 8,
        VT_PROF_TYPE = 10,
        VT_CTRL_POINT = 12,
        VT_RETR = 14,
        VT_UPDATE = 16,
        VT_VALUE = 18
    };
    uint32_t offset() const
    {
        return GetField<uint32_t>(VT_OFFSET, 0);
    }
    uint32_t cyc_cnt() const
    {
        return GetField<uint32_t>(VT_CYC_CNT, 0);
    }
    uint32_t path_idx() const
    {
        return GetField<uint32_t>(VT_PATH_IDX, 0);
    }
    uint32_t prof_type() const
    {
        return GetField<uint32_t>(VT_PROF_TYPE, 0);
    }
    uint32_t ctrl_point() const
    {
        return GetField<uint32_t>(VT_CTRL_POINT, 0);
    }
    uint32_t retr() const
    {
        return GetField<uint32_t>(VT_RETR, 0);
    }
    uint32_t update() const
    {
        return GetField<uint32_t>(VT_UPDATE, 0);
    }
    uint32_t value() const
    {
        return GetField<uint32_t>(VT_VALUE, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<uint32_t>(verifier, VT_OFFSET, 4) &&
               VerifyField<uint32_t>(verifier, VT_CYC_CNT, 4) &&
               VerifyField<uint32_t>(verifier, VT_PATH_IDX, 4) &&
               VerifyField<uint32_t>(verifier, VT_PROF_TYPE, 4) &&
               VerifyField<uint32_t>(verifier, VT_CTRL_POINT, 4) &&
               VerifyField<uint32_t>(verifier, VT_RETR, 4) &&
               VerifyField<uint32_t>(verifier, VT_UPDATE, 4) &&
               VerifyField<uint32_t>(verifier, VT_VALUE, 4) &&
               verifier.EndTable();
    }
};

struct ProfileLongBuilder
{
    typedef ProfileLong Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_offset(uint32_t offset)
    {
        fbb_.AddElement<uint32_t>(ProfileLong::VT_OFFSET, offset, 0);
    }
    void add_cyc_cnt(uint32_t cyc_cnt)
    {
        fbb_.AddElement<uint32_t>(ProfileLong::VT_CYC_CNT, cyc_cnt, 0);
    }
    void add_path_idx(uint32_t path_idx)
    {
        fbb_.AddElement<uint32_t>(ProfileLong::VT_PATH_IDX, path_idx, 0);
    }
    void add_prof_type(uint32_t prof_type)
    {
        fbb_.AddElement<uint32_t>(ProfileLong::VT_PROF_TYPE, prof_type, 0);
    }
    void add_ctrl_point(uint32_t ctrl_point)
    {
        fbb_.AddElement<uint32_t>(ProfileLong::VT_CTRL_POINT, ctrl_point, 0);
    }
    void add_retr(uint32_t retr)
    {
        fbb_.AddElement<uint32_t>(ProfileLong::VT_RETR, retr, 0);
    }
    void add_update(uint32_t update)
    {
        fbb_.AddElement<uint32_t>(ProfileLong::VT_UPDATE, update, 0);
    }
    void add_value(uint32_t value)
    {
        fbb_.AddElement<uint32_t>(ProfileLong::VT_VALUE, value, 0);
    }
    explicit ProfileLongBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<ProfileLong> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<ProfileLong>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<ProfileLong> CreateProfileLong(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    uint32_t offset = 0,
    uint32_t cyc_cnt = 0,
    uint32_t path_idx = 0,
    uint32_t prof_type = 0,
    uint32_t ctrl_point = 0,
    uint32_t retr = 0,
    uint32_t update = 0,
    uint32_t value = 0)
{
    ProfileLongBuilder builder_(_fbb);
    builder_.add_value(value);
    builder_.add_update(update);
    builder_.add_retr(retr);
    builder_.add_ctrl_point(ctrl_point);
    builder_.add_prof_type(prof_type);
    builder_.add_path_idx(path_idx);
    builder_.add_cyc_cnt(cyc_cnt);
    builder_.add_offset(offset);
    return builder_.Finish();
}

struct MetaData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef MetaDataBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_MAP_PROVIDER = 4,
        VT_COUNTRY_CODE = 6,
        VT_CYC_CNT = 8,
        VT_PROT_VER_MAJOR = 10,
        VT_PROT_VER_MINOR_STUB = 12,
        VT_DRV_SIDE = 14,
        VT_REGION_CODE = 16,
        VT_MAP_VER_QTR = 18,
        VT_MAP_VER_YEAY = 20,
        VT_REVERVED = 22,
        VT_SPD_UNITS = 24,
        VT_PROT_VER_MINOR = 26,
        VT_HARDWARE_VERSION = 28,
        VT_APK_VERSION = 30,
        VT_SDK_VERSION = 32
    };
    uint32_t map_provider() const
    {
        return GetField<uint32_t>(VT_MAP_PROVIDER, 0);
    }
    uint32_t country_code() const
    {
        return GetField<uint32_t>(VT_COUNTRY_CODE, 0);
    }
    uint32_t cyc_cnt() const
    {
        return GetField<uint32_t>(VT_CYC_CNT, 0);
    }
    uint32_t prot_ver_major() const
    {
        return GetField<uint32_t>(VT_PROT_VER_MAJOR, 0);
    }
    uint32_t prot_ver_minor_stub() const
    {
        return GetField<uint32_t>(VT_PROT_VER_MINOR_STUB, 0);
    }
    uint32_t drv_side() const
    {
        return GetField<uint32_t>(VT_DRV_SIDE, 0);
    }
    uint32_t region_code() const
    {
        return GetField<uint32_t>(VT_REGION_CODE, 0);
    }
    uint32_t map_ver_qtr() const
    {
        return GetField<uint32_t>(VT_MAP_VER_QTR, 0);
    }
    uint32_t map_ver_yeay() const
    {
        return GetField<uint32_t>(VT_MAP_VER_YEAY, 0);
    }
    uint32_t reverved() const
    {
        return GetField<uint32_t>(VT_REVERVED, 0);
    }
    uint32_t spd_units() const
    {
        return GetField<uint32_t>(VT_SPD_UNITS, 0);
    }
    uint32_t prot_ver_minor() const
    {
        return GetField<uint32_t>(VT_PROT_VER_MINOR, 0);
    }
    uint32_t hardware_version() const
    {
        return GetField<uint32_t>(VT_HARDWARE_VERSION, 0);
    }
    const ::flatbuffers::String* apk_version() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_APK_VERSION);
    }
    const ::flatbuffers::String* sdk_version() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_SDK_VERSION);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<uint32_t>(verifier, VT_MAP_PROVIDER, 4) &&
               VerifyField<uint32_t>(verifier, VT_COUNTRY_CODE, 4) &&
               VerifyField<uint32_t>(verifier, VT_CYC_CNT, 4) &&
               VerifyField<uint32_t>(verifier, VT_PROT_VER_MAJOR, 4) &&
               VerifyField<uint32_t>(verifier, VT_PROT_VER_MINOR_STUB, 4) &&
               VerifyField<uint32_t>(verifier, VT_DRV_SIDE, 4) &&
               VerifyField<uint32_t>(verifier, VT_REGION_CODE, 4) &&
               VerifyField<uint32_t>(verifier, VT_MAP_VER_QTR, 4) &&
               VerifyField<uint32_t>(verifier, VT_MAP_VER_YEAY, 4) &&
               VerifyField<uint32_t>(verifier, VT_REVERVED, 4) &&
               VerifyField<uint32_t>(verifier, VT_SPD_UNITS, 4) &&
               VerifyField<uint32_t>(verifier, VT_PROT_VER_MINOR, 4) &&
               VerifyField<uint32_t>(verifier, VT_HARDWARE_VERSION, 4) &&
               VerifyOffset(verifier, VT_APK_VERSION) &&
               verifier.VerifyString(apk_version()) &&
               VerifyOffset(verifier, VT_SDK_VERSION) &&
               verifier.VerifyString(sdk_version()) &&
               verifier.EndTable();
    }
};

struct MetaDataBuilder
{
    typedef MetaData Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_map_provider(uint32_t map_provider)
    {
        fbb_.AddElement<uint32_t>(MetaData::VT_MAP_PROVIDER, map_provider, 0);
    }
    void add_country_code(uint32_t country_code)
    {
        fbb_.AddElement<uint32_t>(MetaData::VT_COUNTRY_CODE, country_code, 0);
    }
    void add_cyc_cnt(uint32_t cyc_cnt)
    {
        fbb_.AddElement<uint32_t>(MetaData::VT_CYC_CNT, cyc_cnt, 0);
    }
    void add_prot_ver_major(uint32_t prot_ver_major)
    {
        fbb_.AddElement<uint32_t>(MetaData::VT_PROT_VER_MAJOR, prot_ver_major, 0);
    }
    void add_prot_ver_minor_stub(uint32_t prot_ver_minor_stub)
    {
        fbb_.AddElement<uint32_t>(MetaData::VT_PROT_VER_MINOR_STUB, prot_ver_minor_stub, 0);
    }
    void add_drv_side(uint32_t drv_side)
    {
        fbb_.AddElement<uint32_t>(MetaData::VT_DRV_SIDE, drv_side, 0);
    }
    void add_region_code(uint32_t region_code)
    {
        fbb_.AddElement<uint32_t>(MetaData::VT_REGION_CODE, region_code, 0);
    }
    void add_map_ver_qtr(uint32_t map_ver_qtr)
    {
        fbb_.AddElement<uint32_t>(MetaData::VT_MAP_VER_QTR, map_ver_qtr, 0);
    }
    void add_map_ver_yeay(uint32_t map_ver_yeay)
    {
        fbb_.AddElement<uint32_t>(MetaData::VT_MAP_VER_YEAY, map_ver_yeay, 0);
    }
    void add_reverved(uint32_t reverved)
    {
        fbb_.AddElement<uint32_t>(MetaData::VT_REVERVED, reverved, 0);
    }
    void add_spd_units(uint32_t spd_units)
    {
        fbb_.AddElement<uint32_t>(MetaData::VT_SPD_UNITS, spd_units, 0);
    }
    void add_prot_ver_minor(uint32_t prot_ver_minor)
    {
        fbb_.AddElement<uint32_t>(MetaData::VT_PROT_VER_MINOR, prot_ver_minor, 0);
    }
    void add_hardware_version(uint32_t hardware_version)
    {
        fbb_.AddElement<uint32_t>(MetaData::VT_HARDWARE_VERSION, hardware_version, 0);
    }
    void add_apk_version(::flatbuffers::Offset<::flatbuffers::String> apk_version)
    {
        fbb_.AddOffset(MetaData::VT_APK_VERSION, apk_version);
    }
    void add_sdk_version(::flatbuffers::Offset<::flatbuffers::String> sdk_version)
    {
        fbb_.AddOffset(MetaData::VT_SDK_VERSION, sdk_version);
    }
    explicit MetaDataBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<MetaData> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<MetaData>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<MetaData> CreateMetaData(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    uint32_t map_provider = 0,
    uint32_t country_code = 0,
    uint32_t cyc_cnt = 0,
    uint32_t prot_ver_major = 0,
    uint32_t prot_ver_minor_stub = 0,
    uint32_t drv_side = 0,
    uint32_t region_code = 0,
    uint32_t map_ver_qtr = 0,
    uint32_t map_ver_yeay = 0,
    uint32_t reverved = 0,
    uint32_t spd_units = 0,
    uint32_t prot_ver_minor = 0,
    uint32_t hardware_version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> apk_version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sdk_version = 0)
{
    MetaDataBuilder builder_(_fbb);
    builder_.add_sdk_version(sdk_version);
    builder_.add_apk_version(apk_version);
    builder_.add_hardware_version(hardware_version);
    builder_.add_prot_ver_minor(prot_ver_minor);
    builder_.add_spd_units(spd_units);
    builder_.add_reverved(reverved);
    builder_.add_map_ver_yeay(map_ver_yeay);
    builder_.add_map_ver_qtr(map_ver_qtr);
    builder_.add_region_code(region_code);
    builder_.add_drv_side(drv_side);
    builder_.add_prot_ver_minor_stub(prot_ver_minor_stub);
    builder_.add_prot_ver_major(prot_ver_major);
    builder_.add_cyc_cnt(cyc_cnt);
    builder_.add_country_code(country_code);
    builder_.add_map_provider(map_provider);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<MetaData> CreateMetaDataDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    uint32_t map_provider = 0,
    uint32_t country_code = 0,
    uint32_t cyc_cnt = 0,
    uint32_t prot_ver_major = 0,
    uint32_t prot_ver_minor_stub = 0,
    uint32_t drv_side = 0,
    uint32_t region_code = 0,
    uint32_t map_ver_qtr = 0,
    uint32_t map_ver_yeay = 0,
    uint32_t reverved = 0,
    uint32_t spd_units = 0,
    uint32_t prot_ver_minor = 0,
    uint32_t hardware_version = 0,
    const char* apk_version = nullptr,
    const char* sdk_version = nullptr)
{
    auto apk_version__ = apk_version ? _fbb.CreateString(apk_version) : 0;
    auto sdk_version__ = sdk_version ? _fbb.CreateString(sdk_version) : 0;
    return com::nio::map::adas::flat::CreateMetaData(
               _fbb,
               map_provider,
               country_code,
               cyc_cnt,
               prot_ver_major,
               prot_ver_minor_stub,
               drv_side,
               region_code,
               map_ver_qtr,
               map_ver_yeay,
               reverved,
               spd_units,
               prot_ver_minor,
               hardware_version,
               apk_version__,
               sdk_version__);
}

struct CustomMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef CustomMessageBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_CYCLICCOUNTER = 4,
        VT_HISTORICALSPEED = 6,
        VT_INTERSECTIONTYPE = 8,
        VT_LINKTYPE = 10,
        VT_MESSAGETYPE = 12,
        VT_OFFSET = 14,
        VT_PATHINDEX = 16,
        VT_PROFILETYPE = 18,
        VT_RESERVED1 = 20,
        VT_RESERVED2 = 22,
        VT_RETRANSMISSION = 24,
        VT_ROADDIRECTION = 26,
        VT_ROADTYPE = 28,
        VT_UPDATE = 30
    };
    uint32_t cyclicCounter() const
    {
        return GetField<uint32_t>(VT_CYCLICCOUNTER, 0);
    }
    uint32_t historicalSpeed() const
    {
        return GetField<uint32_t>(VT_HISTORICALSPEED, 0);
    }
    uint32_t intersectionType() const
    {
        return GetField<uint32_t>(VT_INTERSECTIONTYPE, 0);
    }
    uint32_t linkType() const
    {
        return GetField<uint32_t>(VT_LINKTYPE, 0);
    }
    uint32_t messageType() const
    {
        return GetField<uint32_t>(VT_MESSAGETYPE, 0);
    }
    uint32_t offset() const
    {
        return GetField<uint32_t>(VT_OFFSET, 0);
    }
    uint32_t pathIndex() const
    {
        return GetField<uint32_t>(VT_PATHINDEX, 0);
    }
    uint32_t profileType() const
    {
        return GetField<uint32_t>(VT_PROFILETYPE, 0);
    }
    uint32_t reserved1() const
    {
        return GetField<uint32_t>(VT_RESERVED1, 0);
    }
    uint32_t reserved2() const
    {
        return GetField<uint32_t>(VT_RESERVED2, 0);
    }
    uint32_t retransmission() const
    {
        return GetField<uint32_t>(VT_RETRANSMISSION, 0);
    }
    uint32_t roadDirection() const
    {
        return GetField<uint32_t>(VT_ROADDIRECTION, 0);
    }
    uint32_t roadType() const
    {
        return GetField<uint32_t>(VT_ROADTYPE, 0);
    }
    uint32_t update() const
    {
        return GetField<uint32_t>(VT_UPDATE, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<uint32_t>(verifier, VT_CYCLICCOUNTER, 4) &&
               VerifyField<uint32_t>(verifier, VT_HISTORICALSPEED, 4) &&
               VerifyField<uint32_t>(verifier, VT_INTERSECTIONTYPE, 4) &&
               VerifyField<uint32_t>(verifier, VT_LINKTYPE, 4) &&
               VerifyField<uint32_t>(verifier, VT_MESSAGETYPE, 4) &&
               VerifyField<uint32_t>(verifier, VT_OFFSET, 4) &&
               VerifyField<uint32_t>(verifier, VT_PATHINDEX, 4) &&
               VerifyField<uint32_t>(verifier, VT_PROFILETYPE, 4) &&
               VerifyField<uint32_t>(verifier, VT_RESERVED1, 4) &&
               VerifyField<uint32_t>(verifier, VT_RESERVED2, 4) &&
               VerifyField<uint32_t>(verifier, VT_RETRANSMISSION, 4) &&
               VerifyField<uint32_t>(verifier, VT_ROADDIRECTION, 4) &&
               VerifyField<uint32_t>(verifier, VT_ROADTYPE, 4) &&
               VerifyField<uint32_t>(verifier, VT_UPDATE, 4) &&
               verifier.EndTable();
    }
};

struct CustomMessageBuilder
{
    typedef CustomMessage Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_cyclicCounter(uint32_t cyclicCounter)
    {
        fbb_.AddElement<uint32_t>(CustomMessage::VT_CYCLICCOUNTER, cyclicCounter, 0);
    }
    void add_historicalSpeed(uint32_t historicalSpeed)
    {
        fbb_.AddElement<uint32_t>(CustomMessage::VT_HISTORICALSPEED, historicalSpeed, 0);
    }
    void add_intersectionType(uint32_t intersectionType)
    {
        fbb_.AddElement<uint32_t>(CustomMessage::VT_INTERSECTIONTYPE, intersectionType, 0);
    }
    void add_linkType(uint32_t linkType)
    {
        fbb_.AddElement<uint32_t>(CustomMessage::VT_LINKTYPE, linkType, 0);
    }
    void add_messageType(uint32_t messageType)
    {
        fbb_.AddElement<uint32_t>(CustomMessage::VT_MESSAGETYPE, messageType, 0);
    }
    void add_offset(uint32_t offset)
    {
        fbb_.AddElement<uint32_t>(CustomMessage::VT_OFFSET, offset, 0);
    }
    void add_pathIndex(uint32_t pathIndex)
    {
        fbb_.AddElement<uint32_t>(CustomMessage::VT_PATHINDEX, pathIndex, 0);
    }
    void add_profileType(uint32_t profileType)
    {
        fbb_.AddElement<uint32_t>(CustomMessage::VT_PROFILETYPE, profileType, 0);
    }
    void add_reserved1(uint32_t reserved1)
    {
        fbb_.AddElement<uint32_t>(CustomMessage::VT_RESERVED1, reserved1, 0);
    }
    void add_reserved2(uint32_t reserved2)
    {
        fbb_.AddElement<uint32_t>(CustomMessage::VT_RESERVED2, reserved2, 0);
    }
    void add_retransmission(uint32_t retransmission)
    {
        fbb_.AddElement<uint32_t>(CustomMessage::VT_RETRANSMISSION, retransmission, 0);
    }
    void add_roadDirection(uint32_t roadDirection)
    {
        fbb_.AddElement<uint32_t>(CustomMessage::VT_ROADDIRECTION, roadDirection, 0);
    }
    void add_roadType(uint32_t roadType)
    {
        fbb_.AddElement<uint32_t>(CustomMessage::VT_ROADTYPE, roadType, 0);
    }
    void add_update(uint32_t update)
    {
        fbb_.AddElement<uint32_t>(CustomMessage::VT_UPDATE, update, 0);
    }
    explicit CustomMessageBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<CustomMessage> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<CustomMessage>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<CustomMessage> CreateCustomMessage(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    uint32_t cyclicCounter = 0,
    uint32_t historicalSpeed = 0,
    uint32_t intersectionType = 0,
    uint32_t linkType = 0,
    uint32_t messageType = 0,
    uint32_t offset = 0,
    uint32_t pathIndex = 0,
    uint32_t profileType = 0,
    uint32_t reserved1 = 0,
    uint32_t reserved2 = 0,
    uint32_t retransmission = 0,
    uint32_t roadDirection = 0,
    uint32_t roadType = 0,
    uint32_t update = 0)
{
    CustomMessageBuilder builder_(_fbb);
    builder_.add_update(update);
    builder_.add_roadType(roadType);
    builder_.add_roadDirection(roadDirection);
    builder_.add_retransmission(retransmission);
    builder_.add_reserved2(reserved2);
    builder_.add_reserved1(reserved1);
    builder_.add_profileType(profileType);
    builder_.add_pathIndex(pathIndex);
    builder_.add_offset(offset);
    builder_.add_messageType(messageType);
    builder_.add_linkType(linkType);
    builder_.add_intersectionType(intersectionType);
    builder_.add_historicalSpeed(historicalSpeed);
    builder_.add_cyclicCounter(cyclicCounter);
    return builder_.Finish();
}

struct MapMatchInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef MapMatchInfoBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_MATCHSTATE = 4,
        VT_ROADCLASS = 6
    };
    int32_t matchState() const
    {
        return GetField<int32_t>(VT_MATCHSTATE, 0);
    }
    com::nio::map::adas::flat::RoadClass roadClass() const
    {
        return static_cast<com::nio::map::adas::flat::RoadClass>(GetField<int32_t>(VT_ROADCLASS, 0));
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<int32_t>(verifier, VT_MATCHSTATE, 4) &&
               VerifyField<int32_t>(verifier, VT_ROADCLASS, 4) &&
               verifier.EndTable();
    }
};

struct MapMatchInfoBuilder
{
    typedef MapMatchInfo Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_matchState(int32_t matchState)
    {
        fbb_.AddElement<int32_t>(MapMatchInfo::VT_MATCHSTATE, matchState, 0);
    }
    void add_roadClass(com::nio::map::adas::flat::RoadClass roadClass)
    {
        fbb_.AddElement<int32_t>(MapMatchInfo::VT_ROADCLASS, static_cast<int32_t>(roadClass), 0);
    }
    explicit MapMatchInfoBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<MapMatchInfo> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<MapMatchInfo>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<MapMatchInfo> CreateMapMatchInfo(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    int32_t matchState = 0,
    com::nio::map::adas::flat::RoadClass roadClass = com::nio::map::adas::flat::RoadClass_R_NONE)
{
    MapMatchInfoBuilder builder_(_fbb);
    builder_.add_roadClass(roadClass);
    builder_.add_matchState(matchState);
    return builder_.Finish();
}

struct SpeedLimitInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef SpeedLimitInfoBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_SPEEDLIMIT = 4,
        VT_SPEEDLIMITTYPE = 6
    };
    int32_t speedLimit() const
    {
        return GetField<int32_t>(VT_SPEEDLIMIT, 0);
    }
    int32_t speedLimitType() const
    {
        return GetField<int32_t>(VT_SPEEDLIMITTYPE, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<int32_t>(verifier, VT_SPEEDLIMIT, 4) &&
               VerifyField<int32_t>(verifier, VT_SPEEDLIMITTYPE, 4) &&
               verifier.EndTable();
    }
};

struct SpeedLimitInfoBuilder
{
    typedef SpeedLimitInfo Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_speedLimit(int32_t speedLimit)
    {
        fbb_.AddElement<int32_t>(SpeedLimitInfo::VT_SPEEDLIMIT, speedLimit, 0);
    }
    void add_speedLimitType(int32_t speedLimitType)
    {
        fbb_.AddElement<int32_t>(SpeedLimitInfo::VT_SPEEDLIMITTYPE, speedLimitType, 0);
    }
    explicit SpeedLimitInfoBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<SpeedLimitInfo> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<SpeedLimitInfo>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<SpeedLimitInfo> CreateSpeedLimitInfo(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    int32_t speedLimit = 0,
    int32_t speedLimitType = 0)
{
    SpeedLimitInfoBuilder builder_(_fbb);
    builder_.add_speedLimitType(speedLimitType);
    builder_.add_speedLimit(speedLimit);
    return builder_.Finish();
}

struct LaneInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef LaneInfoBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_SHOW = 4,
        VT_LANENRINFO = 6,
        VT_DISTTOLANEINFOGUIDE = 8,
        VT_ID = 10
    };
    bool show() const
    {
        return GetField<uint8_t>(VT_SHOW, 0) != 0;
    }
    const ::flatbuffers::Vector<int32_t>* laneNrInfo() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_LANENRINFO);
    }
    int32_t distToLaneInfoGuide() const
    {
        return GetField<int32_t>(VT_DISTTOLANEINFOGUIDE, 0);
    }
    const ::flatbuffers::String* id() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_ID);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<uint8_t>(verifier, VT_SHOW, 1) &&
               VerifyOffset(verifier, VT_LANENRINFO) &&
               verifier.VerifyVector(laneNrInfo()) &&
               VerifyField<int32_t>(verifier, VT_DISTTOLANEINFOGUIDE, 4) &&
               VerifyOffset(verifier, VT_ID) &&
               verifier.VerifyString(id()) &&
               verifier.EndTable();
    }
};

struct LaneInfoBuilder
{
    typedef LaneInfo Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_show(bool show)
    {
        fbb_.AddElement<uint8_t>(LaneInfo::VT_SHOW, static_cast<uint8_t>(show), 0);
    }
    void add_laneNrInfo(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> laneNrInfo)
    {
        fbb_.AddOffset(LaneInfo::VT_LANENRINFO, laneNrInfo);
    }
    void add_distToLaneInfoGuide(int32_t distToLaneInfoGuide)
    {
        fbb_.AddElement<int32_t>(LaneInfo::VT_DISTTOLANEINFOGUIDE, distToLaneInfoGuide, 0);
    }
    void add_id(::flatbuffers::Offset<::flatbuffers::String> id)
    {
        fbb_.AddOffset(LaneInfo::VT_ID, id);
    }
    explicit LaneInfoBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<LaneInfo> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<LaneInfo>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<LaneInfo> CreateLaneInfo(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    bool show = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> laneNrInfo = 0,
    int32_t distToLaneInfoGuide = 0,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0)
{
    LaneInfoBuilder builder_(_fbb);
    builder_.add_id(id);
    builder_.add_distToLaneInfoGuide(distToLaneInfoGuide);
    builder_.add_laneNrInfo(laneNrInfo);
    builder_.add_show(show);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<LaneInfo> CreateLaneInfoDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    bool show = false,
    const std::vector<int32_t>* laneNrInfo = nullptr,
    int32_t distToLaneInfoGuide = 0,
    const char* id = nullptr)
{
    auto laneNrInfo__ = laneNrInfo ? _fbb.CreateVector<int32_t>(*laneNrInfo) : 0;
    auto id__ = id ? _fbb.CreateString(id) : 0;
    return com::nio::map::adas::flat::CreateLaneInfo(
               _fbb,
               show,
               laneNrInfo__,
               distToLaneInfoGuide,
               id__);
}

struct TurnInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef TurnInfoBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_DISTTOFIRSTTURN = 4,
        VT_FIRSTTURNINFO = 6,
        VT_DISTTOSECONDTURN = 8,
        VT_SECONDTURNINFO = 10
    };
    int32_t distToFirstTurn() const
    {
        return GetField<int32_t>(VT_DISTTOFIRSTTURN, 0);
    }
    int32_t firstTurnInfo() const
    {
        return GetField<int32_t>(VT_FIRSTTURNINFO, 0);
    }
    int32_t distToSecondTurn() const
    {
        return GetField<int32_t>(VT_DISTTOSECONDTURN, 0);
    }
    int32_t secondTurnInfo() const
    {
        return GetField<int32_t>(VT_SECONDTURNINFO, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<int32_t>(verifier, VT_DISTTOFIRSTTURN, 4) &&
               VerifyField<int32_t>(verifier, VT_FIRSTTURNINFO, 4) &&
               VerifyField<int32_t>(verifier, VT_DISTTOSECONDTURN, 4) &&
               VerifyField<int32_t>(verifier, VT_SECONDTURNINFO, 4) &&
               verifier.EndTable();
    }
};

struct TurnInfoBuilder
{
    typedef TurnInfo Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_distToFirstTurn(int32_t distToFirstTurn)
    {
        fbb_.AddElement<int32_t>(TurnInfo::VT_DISTTOFIRSTTURN, distToFirstTurn, 0);
    }
    void add_firstTurnInfo(int32_t firstTurnInfo)
    {
        fbb_.AddElement<int32_t>(TurnInfo::VT_FIRSTTURNINFO, firstTurnInfo, 0);
    }
    void add_distToSecondTurn(int32_t distToSecondTurn)
    {
        fbb_.AddElement<int32_t>(TurnInfo::VT_DISTTOSECONDTURN, distToSecondTurn, 0);
    }
    void add_secondTurnInfo(int32_t secondTurnInfo)
    {
        fbb_.AddElement<int32_t>(TurnInfo::VT_SECONDTURNINFO, secondTurnInfo, 0);
    }
    explicit TurnInfoBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<TurnInfo> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<TurnInfo>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<TurnInfo> CreateTurnInfo(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    int32_t distToFirstTurn = 0,
    int32_t firstTurnInfo = 0,
    int32_t distToSecondTurn = 0,
    int32_t secondTurnInfo = 0)
{
    TurnInfoBuilder builder_(_fbb);
    builder_.add_secondTurnInfo(secondTurnInfo);
    builder_.add_distToSecondTurn(distToSecondTurn);
    builder_.add_firstTurnInfo(firstTurnInfo);
    builder_.add_distToFirstTurn(distToFirstTurn);
    return builder_.Finish();
}

struct EnterNopRoadInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef EnterNopRoadInfoBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_DISTANCE = 4
    };
    int32_t distance() const
    {
        return GetField<int32_t>(VT_DISTANCE, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<int32_t>(verifier, VT_DISTANCE, 4) &&
               verifier.EndTable();
    }
};

struct EnterNopRoadInfoBuilder
{
    typedef EnterNopRoadInfo Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_distance(int32_t distance)
    {
        fbb_.AddElement<int32_t>(EnterNopRoadInfo::VT_DISTANCE, distance, 0);
    }
    explicit EnterNopRoadInfoBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<EnterNopRoadInfo> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<EnterNopRoadInfo>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<EnterNopRoadInfo> CreateEnterNopRoadInfo(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    int32_t distance = 0)
{
    EnterNopRoadInfoBuilder builder_(_fbb);
    builder_.add_distance(distance);
    return builder_.Finish();
}

struct ExitNopRoadInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef ExitNopRoadInfoBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_DISTANCE = 4
    };
    int32_t distance() const
    {
        return GetField<int32_t>(VT_DISTANCE, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<int32_t>(verifier, VT_DISTANCE, 4) &&
               verifier.EndTable();
    }
};

struct ExitNopRoadInfoBuilder
{
    typedef ExitNopRoadInfo Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_distance(int32_t distance)
    {
        fbb_.AddElement<int32_t>(ExitNopRoadInfo::VT_DISTANCE, distance, 0);
    }
    explicit ExitNopRoadInfoBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<ExitNopRoadInfo> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<ExitNopRoadInfo>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<ExitNopRoadInfo> CreateExitNopRoadInfo(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    int32_t distance = 0)
{
    ExitNopRoadInfoBuilder builder_(_fbb);
    builder_.add_distance(distance);
    return builder_.Finish();
}

struct EnterNopRampInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef EnterNopRampInfoBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_DISTANCE = 4
    };
    int32_t distance() const
    {
        return GetField<int32_t>(VT_DISTANCE, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<int32_t>(verifier, VT_DISTANCE, 4) &&
               verifier.EndTable();
    }
};

struct EnterNopRampInfoBuilder
{
    typedef EnterNopRampInfo Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_distance(int32_t distance)
    {
        fbb_.AddElement<int32_t>(EnterNopRampInfo::VT_DISTANCE, distance, 0);
    }
    explicit EnterNopRampInfoBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<EnterNopRampInfo> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<EnterNopRampInfo>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<EnterNopRampInfo> CreateEnterNopRampInfo(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    int32_t distance = 0)
{
    EnterNopRampInfoBuilder builder_(_fbb);
    builder_.add_distance(distance);
    return builder_.Finish();
}

struct HeartBeatInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef HeartBeatInfoBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_HEARTBEAT = 4,
        VT_RELIABLESTATE = 6,
        VT_NAVIGATIONSTATE = 8
    };
    int32_t heartBeat() const
    {
        return GetField<int32_t>(VT_HEARTBEAT, 0);
    }
    com::nio::map::adas::flat::ReliableState reliableState() const
    {
        return static_cast<com::nio::map::adas::flat::ReliableState>(GetField<int32_t>(VT_RELIABLESTATE, 0));
    }
    com::nio::map::adas::flat::NavigationState navigationState() const
    {
        return static_cast<com::nio::map::adas::flat::NavigationState>(GetField<int32_t>(VT_NAVIGATIONSTATE, 0));
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<int32_t>(verifier, VT_HEARTBEAT, 4) &&
               VerifyField<int32_t>(verifier, VT_RELIABLESTATE, 4) &&
               VerifyField<int32_t>(verifier, VT_NAVIGATIONSTATE, 4) &&
               verifier.EndTable();
    }
};

struct HeartBeatInfoBuilder
{
    typedef HeartBeatInfo Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_heartBeat(int32_t heartBeat)
    {
        fbb_.AddElement<int32_t>(HeartBeatInfo::VT_HEARTBEAT, heartBeat, 0);
    }
    void add_reliableState(com::nio::map::adas::flat::ReliableState reliableState)
    {
        fbb_.AddElement<int32_t>(HeartBeatInfo::VT_RELIABLESTATE, static_cast<int32_t>(reliableState), 0);
    }
    void add_navigationState(com::nio::map::adas::flat::NavigationState navigationState)
    {
        fbb_.AddElement<int32_t>(HeartBeatInfo::VT_NAVIGATIONSTATE, static_cast<int32_t>(navigationState), 0);
    }
    explicit HeartBeatInfoBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<HeartBeatInfo> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<HeartBeatInfo>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<HeartBeatInfo> CreateHeartBeatInfo(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    int32_t heartBeat = 0,
    com::nio::map::adas::flat::ReliableState reliableState = com::nio::map::adas::flat::ReliableState_RS_NONE,
    com::nio::map::adas::flat::NavigationState navigationState = com::nio::map::adas::flat::NavigationState_NS_NONE)
{
    HeartBeatInfoBuilder builder_(_fbb);
    builder_.add_navigationState(navigationState);
    builder_.add_reliableState(reliableState);
    builder_.add_heartBeat(heartBeat);
    return builder_.Finish();
}

struct GPSLocation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef GPSLocationBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_LATITUDE = 4,
        VT_LONGITUDE = 6,
        VT_BEARING = 8,
        VT_ALTITUDE = 10,
        VT_LOCATIONTYPE = 12
    };
    double latitude() const
    {
        return GetField<double>(VT_LATITUDE, 0.0);
    }
    double longitude() const
    {
        return GetField<double>(VT_LONGITUDE, 0.0);
    }
    double bearing() const
    {
        return GetField<double>(VT_BEARING, 0.0);
    }
    double altitude() const
    {
        return GetField<double>(VT_ALTITUDE, 0.0);
    }
    com::nio::map::adas::flat::GPSLocationType locationType() const
    {
        return static_cast<com::nio::map::adas::flat::GPSLocationType>(GetField<int32_t>(VT_LOCATIONTYPE, 0));
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<double>(verifier, VT_LATITUDE, 8) &&
               VerifyField<double>(verifier, VT_LONGITUDE, 8) &&
               VerifyField<double>(verifier, VT_BEARING, 8) &&
               VerifyField<double>(verifier, VT_ALTITUDE, 8) &&
               VerifyField<int32_t>(verifier, VT_LOCATIONTYPE, 4) &&
               verifier.EndTable();
    }
};

struct GPSLocationBuilder
{
    typedef GPSLocation Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_latitude(double latitude)
    {
        fbb_.AddElement<double>(GPSLocation::VT_LATITUDE, latitude, 0.0);
    }
    void add_longitude(double longitude)
    {
        fbb_.AddElement<double>(GPSLocation::VT_LONGITUDE, longitude, 0.0);
    }
    void add_bearing(double bearing)
    {
        fbb_.AddElement<double>(GPSLocation::VT_BEARING, bearing, 0.0);
    }
    void add_altitude(double altitude)
    {
        fbb_.AddElement<double>(GPSLocation::VT_ALTITUDE, altitude, 0.0);
    }
    void add_locationType(com::nio::map::adas::flat::GPSLocationType locationType)
    {
        fbb_.AddElement<int32_t>(GPSLocation::VT_LOCATIONTYPE, static_cast<int32_t>(locationType), 0);
    }
    explicit GPSLocationBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<GPSLocation> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<GPSLocation>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<GPSLocation> CreateGPSLocation(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    double latitude = 0.0,
    double longitude = 0.0,
    double bearing = 0.0,
    double altitude = 0.0,
    com::nio::map::adas::flat::GPSLocationType locationType = com::nio::map::adas::flat::GPSLocationType_G_NOT_VALID)
{
    GPSLocationBuilder builder_(_fbb);
    builder_.add_altitude(altitude);
    builder_.add_bearing(bearing);
    builder_.add_longitude(longitude);
    builder_.add_latitude(latitude);
    builder_.add_locationType(locationType);
    return builder_.Finish();
}

struct AdasInfoData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef AdasInfoDataBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_ADASINFO_TYPE = 4,
        VT_ADASINFO = 6
    };
    com::nio::map::adas::flat::AdasInfo adasInfo_type() const
    {
        return static_cast<com::nio::map::adas::flat::AdasInfo>(GetField<uint8_t>(VT_ADASINFO_TYPE, 0));
    }
    const void* adasInfo() const
    {
        return GetPointer<const void*>(VT_ADASINFO);
    }
    template<typename T> const T* adasInfo_as() const;
    const com::nio::map::adas::flat::TrafficSign* adasInfo_as_trafficSign() const
    {
        return adasInfo_type() == com::nio::map::adas::flat::AdasInfo_trafficSign ? static_cast<const com::nio::map::adas::flat::TrafficSign*>(adasInfo()) : nullptr;
    }
    const com::nio::map::adas::flat::Position* adasInfo_as_position() const
    {
        return adasInfo_type() == com::nio::map::adas::flat::AdasInfo_position ? static_cast<const com::nio::map::adas::flat::Position*>(adasInfo()) : nullptr;
    }
    const com::nio::map::adas::flat::Segment* adasInfo_as_segment() const
    {
        return adasInfo_type() == com::nio::map::adas::flat::AdasInfo_segment ? static_cast<const com::nio::map::adas::flat::Segment*>(adasInfo()) : nullptr;
    }
    const com::nio::map::adas::flat::Stub* adasInfo_as_stub() const
    {
        return adasInfo_type() == com::nio::map::adas::flat::AdasInfo_stub ? static_cast<const com::nio::map::adas::flat::Stub*>(adasInfo()) : nullptr;
    }
    const com::nio::map::adas::flat::ProfileShort* adasInfo_as_profileShort() const
    {
        return adasInfo_type() == com::nio::map::adas::flat::AdasInfo_profileShort ? static_cast<const com::nio::map::adas::flat::ProfileShort*>(adasInfo()) : nullptr;
    }
    const com::nio::map::adas::flat::ProfileLong* adasInfo_as_profileLong() const
    {
        return adasInfo_type() == com::nio::map::adas::flat::AdasInfo_profileLong ? static_cast<const com::nio::map::adas::flat::ProfileLong*>(adasInfo()) : nullptr;
    }
    const com::nio::map::adas::flat::MetaData* adasInfo_as_metaData() const
    {
        return adasInfo_type() == com::nio::map::adas::flat::AdasInfo_metaData ? static_cast<const com::nio::map::adas::flat::MetaData*>(adasInfo()) : nullptr;
    }
    const com::nio::map::adas::flat::CustomMessage* adasInfo_as_customMessage() const
    {
        return adasInfo_type() == com::nio::map::adas::flat::AdasInfo_customMessage ? static_cast<const com::nio::map::adas::flat::CustomMessage*>(adasInfo()) : nullptr;
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<uint8_t>(verifier, VT_ADASINFO_TYPE, 1) &&
               VerifyOffset(verifier, VT_ADASINFO) &&
               VerifyAdasInfo(verifier, adasInfo(), adasInfo_type()) &&
               verifier.EndTable();
    }
};

template<> inline const com::nio::map::adas::flat::TrafficSign* AdasInfoData::adasInfo_as<com::nio::map::adas::flat::TrafficSign>() const
{
    return adasInfo_as_trafficSign();
}

template<> inline const com::nio::map::adas::flat::Position* AdasInfoData::adasInfo_as<com::nio::map::adas::flat::Position>() const
{
    return adasInfo_as_position();
}

template<> inline const com::nio::map::adas::flat::Segment* AdasInfoData::adasInfo_as<com::nio::map::adas::flat::Segment>() const
{
    return adasInfo_as_segment();
}

template<> inline const com::nio::map::adas::flat::Stub* AdasInfoData::adasInfo_as<com::nio::map::adas::flat::Stub>() const
{
    return adasInfo_as_stub();
}

template<> inline const com::nio::map::adas::flat::ProfileShort* AdasInfoData::adasInfo_as<com::nio::map::adas::flat::ProfileShort>() const
{
    return adasInfo_as_profileShort();
}

template<> inline const com::nio::map::adas::flat::ProfileLong* AdasInfoData::adasInfo_as<com::nio::map::adas::flat::ProfileLong>() const
{
    return adasInfo_as_profileLong();
}

template<> inline const com::nio::map::adas::flat::MetaData* AdasInfoData::adasInfo_as<com::nio::map::adas::flat::MetaData>() const
{
    return adasInfo_as_metaData();
}

template<> inline const com::nio::map::adas::flat::CustomMessage* AdasInfoData::adasInfo_as<com::nio::map::adas::flat::CustomMessage>() const
{
    return adasInfo_as_customMessage();
}

struct AdasInfoDataBuilder
{
    typedef AdasInfoData Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_adasInfo_type(com::nio::map::adas::flat::AdasInfo adasInfo_type)
    {
        fbb_.AddElement<uint8_t>(AdasInfoData::VT_ADASINFO_TYPE, static_cast<uint8_t>(adasInfo_type), 0);
    }
    void add_adasInfo(::flatbuffers::Offset<void> adasInfo)
    {
        fbb_.AddOffset(AdasInfoData::VT_ADASINFO, adasInfo);
    }
    explicit AdasInfoDataBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<AdasInfoData> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<AdasInfoData>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<AdasInfoData> CreateAdasInfoData(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    com::nio::map::adas::flat::AdasInfo adasInfo_type = com::nio::map::adas::flat::AdasInfo_NONE,
    ::flatbuffers::Offset<void> adasInfo = 0)
{
    AdasInfoDataBuilder builder_(_fbb);
    builder_.add_adasInfo(adasInfo);
    builder_.add_adasInfo_type(adasInfo_type);
    return builder_.Finish();
}

struct HighPrecisionMapQueryRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef HighPrecisionMapQueryRequestBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_REQUESTID = 4,
        VT_GPSLOCATIONLIST = 6
    };
    int32_t requestId() const
    {
        return GetField<int32_t>(VT_REQUESTID, 0);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation>>* gpsLocationList() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation>> *>(VT_GPSLOCATIONLIST);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<int32_t>(verifier, VT_REQUESTID, 4) &&
               VerifyOffset(verifier, VT_GPSLOCATIONLIST) &&
               verifier.VerifyVector(gpsLocationList()) &&
               verifier.VerifyVectorOfTables(gpsLocationList()) &&
               verifier.EndTable();
    }
};

struct HighPrecisionMapQueryRequestBuilder
{
    typedef HighPrecisionMapQueryRequest Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_requestId(int32_t requestId)
    {
        fbb_.AddElement<int32_t>(HighPrecisionMapQueryRequest::VT_REQUESTID, requestId, 0);
    }
    void add_gpsLocationList(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation>>> gpsLocationList)
    {
        fbb_.AddOffset(HighPrecisionMapQueryRequest::VT_GPSLOCATIONLIST, gpsLocationList);
    }
    explicit HighPrecisionMapQueryRequestBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<HighPrecisionMapQueryRequest> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<HighPrecisionMapQueryRequest>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<HighPrecisionMapQueryRequest> CreateHighPrecisionMapQueryRequest(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    int32_t requestId = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation>>> gpsLocationList = 0)
{
    HighPrecisionMapQueryRequestBuilder builder_(_fbb);
    builder_.add_gpsLocationList(gpsLocationList);
    builder_.add_requestId(requestId);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<HighPrecisionMapQueryRequest> CreateHighPrecisionMapQueryRequestDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    int32_t requestId = 0,
    const std::vector<::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation>>* gpsLocationList = nullptr)
{
    auto gpsLocationList__ = gpsLocationList ? _fbb.CreateVector<::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation>>(*gpsLocationList) : 0;
    return com::nio::map::adas::flat::CreateHighPrecisionMapQueryRequest(
               _fbb,
               requestId,
               gpsLocationList__);
}

struct HighPrecisionMapQueryResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef HighPrecisionMapQueryResponseBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_REQUESTID = 4,
        VT_STATUS = 6,
        VT_HIGHPRECISIONMAPGPSSTATUS = 8,
        VT_MESSAGE = 10
    };
    int32_t requestId() const
    {
        return GetField<int32_t>(VT_REQUESTID, 0);
    }
    com::nio::map::adas::flat::ResponseStatus status() const
    {
        return static_cast<com::nio::map::adas::flat::ResponseStatus>(GetField<int32_t>(VT_STATUS, 0));
    }
    const ::flatbuffers::Vector<int32_t>* highPrecisionMapGPSStatus() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_HIGHPRECISIONMAPGPSSTATUS);
    }
    const ::flatbuffers::String* message() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_MESSAGE);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<int32_t>(verifier, VT_REQUESTID, 4) &&
               VerifyField<int32_t>(verifier, VT_STATUS, 4) &&
               VerifyOffset(verifier, VT_HIGHPRECISIONMAPGPSSTATUS) &&
               verifier.VerifyVector(highPrecisionMapGPSStatus()) &&
               VerifyOffset(verifier, VT_MESSAGE) &&
               verifier.VerifyString(message()) &&
               verifier.EndTable();
    }
};

struct HighPrecisionMapQueryResponseBuilder
{
    typedef HighPrecisionMapQueryResponse Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_requestId(int32_t requestId)
    {
        fbb_.AddElement<int32_t>(HighPrecisionMapQueryResponse::VT_REQUESTID, requestId, 0);
    }
    void add_status(com::nio::map::adas::flat::ResponseStatus status)
    {
        fbb_.AddElement<int32_t>(HighPrecisionMapQueryResponse::VT_STATUS, static_cast<int32_t>(status), 0);
    }
    void add_highPrecisionMapGPSStatus(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> highPrecisionMapGPSStatus)
    {
        fbb_.AddOffset(HighPrecisionMapQueryResponse::VT_HIGHPRECISIONMAPGPSSTATUS, highPrecisionMapGPSStatus);
    }
    void add_message(::flatbuffers::Offset<::flatbuffers::String> message)
    {
        fbb_.AddOffset(HighPrecisionMapQueryResponse::VT_MESSAGE, message);
    }
    explicit HighPrecisionMapQueryResponseBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<HighPrecisionMapQueryResponse> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<HighPrecisionMapQueryResponse>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<HighPrecisionMapQueryResponse> CreateHighPrecisionMapQueryResponse(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    int32_t requestId = 0,
    com::nio::map::adas::flat::ResponseStatus status = com::nio::map::adas::flat::ResponseStatus_RESP_NOT_VALID,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> highPrecisionMapGPSStatus = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0)
{
    HighPrecisionMapQueryResponseBuilder builder_(_fbb);
    builder_.add_message(message);
    builder_.add_highPrecisionMapGPSStatus(highPrecisionMapGPSStatus);
    builder_.add_status(status);
    builder_.add_requestId(requestId);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<HighPrecisionMapQueryResponse> CreateHighPrecisionMapQueryResponseDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    int32_t requestId = 0,
    com::nio::map::adas::flat::ResponseStatus status = com::nio::map::adas::flat::ResponseStatus_RESP_NOT_VALID,
    const std::vector<int32_t>* highPrecisionMapGPSStatus = nullptr,
    const char* message = nullptr)
{
    auto highPrecisionMapGPSStatus__ = highPrecisionMapGPSStatus ? _fbb.CreateVector<int32_t>(*highPrecisionMapGPSStatus) : 0;
    auto message__ = message ? _fbb.CreateString(message) : 0;
    return com::nio::map::adas::flat::CreateHighPrecisionMapQueryResponse(
               _fbb,
               requestId,
               status,
               highPrecisionMapGPSStatus__,
               message__);
}

struct HighPrecisionMapPoint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef HighPrecisionMapPointBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_HIGHPRECISIONMAPPOINTSTATUS = 4,
        VT_OFFSET = 6,
        VT_LOCATION = 8,
        VT_HDLINKID = 10
    };
    com::nio::map::adas::flat::HighPrecisionMapPointStatus highPrecisionMapPointStatus() const
    {
        return static_cast<com::nio::map::adas::flat::HighPrecisionMapPointStatus>(GetField<int32_t>(VT_HIGHPRECISIONMAPPOINTSTATUS, 0));
    }
    int32_t offset() const
    {
        return GetField<int32_t>(VT_OFFSET, 0);
    }
    const com::nio::map::adas::flat::GPSLocation* location() const
    {
        return GetPointer<const com::nio::map::adas::flat::GPSLocation*>(VT_LOCATION);
    }
    int64_t hdLinkId() const
    {
        return GetField<int64_t>(VT_HDLINKID, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<int32_t>(verifier, VT_HIGHPRECISIONMAPPOINTSTATUS, 4) &&
               VerifyField<int32_t>(verifier, VT_OFFSET, 4) &&
               VerifyOffset(verifier, VT_LOCATION) &&
               verifier.VerifyTable(location()) &&
               VerifyField<int64_t>(verifier, VT_HDLINKID, 8) &&
               verifier.EndTable();
    }
};

struct HighPrecisionMapPointBuilder
{
    typedef HighPrecisionMapPoint Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_highPrecisionMapPointStatus(com::nio::map::adas::flat::HighPrecisionMapPointStatus highPrecisionMapPointStatus)
    {
        fbb_.AddElement<int32_t>(HighPrecisionMapPoint::VT_HIGHPRECISIONMAPPOINTSTATUS, static_cast<int32_t>(highPrecisionMapPointStatus), 0);
    }
    void add_offset(int32_t offset)
    {
        fbb_.AddElement<int32_t>(HighPrecisionMapPoint::VT_OFFSET, offset, 0);
    }
    void add_location(::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation> location)
    {
        fbb_.AddOffset(HighPrecisionMapPoint::VT_LOCATION, location);
    }
    void add_hdLinkId(int64_t hdLinkId)
    {
        fbb_.AddElement<int64_t>(HighPrecisionMapPoint::VT_HDLINKID, hdLinkId, 0);
    }
    explicit HighPrecisionMapPointBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<HighPrecisionMapPoint> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<HighPrecisionMapPoint>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<HighPrecisionMapPoint> CreateHighPrecisionMapPoint(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    com::nio::map::adas::flat::HighPrecisionMapPointStatus highPrecisionMapPointStatus = com::nio::map::adas::flat::HighPrecisionMapPointStatus_HP_POINT_NOT_VALID,
    int32_t offset = 0,
    ::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation> location = 0,
    int64_t hdLinkId = 0)
{
    HighPrecisionMapPointBuilder builder_(_fbb);
    builder_.add_hdLinkId(hdLinkId);
    builder_.add_location(location);
    builder_.add_offset(offset);
    builder_.add_highPrecisionMapPointStatus(highPrecisionMapPointStatus);
    return builder_.Finish();
}

struct HighPrecisionMapPointList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef HighPrecisionMapPointListBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_HIGHPRECISIONMAPPOINT = 4
    };
    const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::HighPrecisionMapPoint>>* highPrecisionMapPoint() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::HighPrecisionMapPoint>> *>(VT_HIGHPRECISIONMAPPOINT);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyOffset(verifier, VT_HIGHPRECISIONMAPPOINT) &&
               verifier.VerifyVector(highPrecisionMapPoint()) &&
               verifier.VerifyVectorOfTables(highPrecisionMapPoint()) &&
               verifier.EndTable();
    }
};

struct HighPrecisionMapPointListBuilder
{
    typedef HighPrecisionMapPointList Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_highPrecisionMapPoint(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::HighPrecisionMapPoint>>> highPrecisionMapPoint)
    {
        fbb_.AddOffset(HighPrecisionMapPointList::VT_HIGHPRECISIONMAPPOINT, highPrecisionMapPoint);
    }
    explicit HighPrecisionMapPointListBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<HighPrecisionMapPointList> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<HighPrecisionMapPointList>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<HighPrecisionMapPointList> CreateHighPrecisionMapPointList(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::HighPrecisionMapPoint>>> highPrecisionMapPoint = 0)
{
    HighPrecisionMapPointListBuilder builder_(_fbb);
    builder_.add_highPrecisionMapPoint(highPrecisionMapPoint);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<HighPrecisionMapPointList> CreateHighPrecisionMapPointListDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<::flatbuffers::Offset<com::nio::map::adas::flat::HighPrecisionMapPoint>>* highPrecisionMapPoint = nullptr)
{
    auto highPrecisionMapPoint__ = highPrecisionMapPoint ? _fbb.CreateVector<::flatbuffers::Offset<com::nio::map::adas::flat::HighPrecisionMapPoint>>(*highPrecisionMapPoint) : 0;
    return com::nio::map::adas::flat::CreateHighPrecisionMapPointList(
               _fbb,
               highPrecisionMapPoint__);
}

struct NowLocationHPMapStatus FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef NowLocationHPMapStatusBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_STATUS = 4
    };
    com::nio::map::adas::flat::NowLocationHPMapStatusConstant status() const
    {
        return static_cast<com::nio::map::adas::flat::NowLocationHPMapStatusConstant>(GetField<int32_t>(VT_STATUS, 0));
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<int32_t>(verifier, VT_STATUS, 4) &&
               verifier.EndTable();
    }
};

struct NowLocationHPMapStatusBuilder
{
    typedef NowLocationHPMapStatus Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_status(com::nio::map::adas::flat::NowLocationHPMapStatusConstant status)
    {
        fbb_.AddElement<int32_t>(NowLocationHPMapStatus::VT_STATUS, static_cast<int32_t>(status), 0);
    }
    explicit NowLocationHPMapStatusBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<NowLocationHPMapStatus> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<NowLocationHPMapStatus>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<NowLocationHPMapStatus> CreateNowLocationHPMapStatus(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    com::nio::map::adas::flat::NowLocationHPMapStatusConstant status = com::nio::map::adas::flat::NowLocationHPMapStatusConstant_N_HP_AREA_NOT_VALID)
{
    NowLocationHPMapStatusBuilder builder_(_fbb);
    builder_.add_status(status);
    return builder_.Finish();
}

struct HighPrecisionQueryEnterResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef HighPrecisionQueryEnterResponseBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_REQUESTID = 4,
        VT_STATUS = 6,
        VT_HIGHPRECISIONMAPPOINTLIST = 8,
        VT_MESSAGE = 10
    };
    int32_t requestId() const
    {
        return GetField<int32_t>(VT_REQUESTID, 0);
    }
    com::nio::map::adas::flat::ResponseStatus status() const
    {
        return static_cast<com::nio::map::adas::flat::ResponseStatus>(GetField<int32_t>(VT_STATUS, 0));
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::HighPrecisionMapPointList>>* highPrecisionMapPointList() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::HighPrecisionMapPointList>> *>(VT_HIGHPRECISIONMAPPOINTLIST);
    }
    const ::flatbuffers::String* message() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_MESSAGE);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<int32_t>(verifier, VT_REQUESTID, 4) &&
               VerifyField<int32_t>(verifier, VT_STATUS, 4) &&
               VerifyOffset(verifier, VT_HIGHPRECISIONMAPPOINTLIST) &&
               verifier.VerifyVector(highPrecisionMapPointList()) &&
               verifier.VerifyVectorOfTables(highPrecisionMapPointList()) &&
               VerifyOffset(verifier, VT_MESSAGE) &&
               verifier.VerifyString(message()) &&
               verifier.EndTable();
    }
};

struct HighPrecisionQueryEnterResponseBuilder
{
    typedef HighPrecisionQueryEnterResponse Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_requestId(int32_t requestId)
    {
        fbb_.AddElement<int32_t>(HighPrecisionQueryEnterResponse::VT_REQUESTID, requestId, 0);
    }
    void add_status(com::nio::map::adas::flat::ResponseStatus status)
    {
        fbb_.AddElement<int32_t>(HighPrecisionQueryEnterResponse::VT_STATUS, static_cast<int32_t>(status), 0);
    }
    void add_highPrecisionMapPointList(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::HighPrecisionMapPointList>>> highPrecisionMapPointList)
    {
        fbb_.AddOffset(HighPrecisionQueryEnterResponse::VT_HIGHPRECISIONMAPPOINTLIST, highPrecisionMapPointList);
    }
    void add_message(::flatbuffers::Offset<::flatbuffers::String> message)
    {
        fbb_.AddOffset(HighPrecisionQueryEnterResponse::VT_MESSAGE, message);
    }
    explicit HighPrecisionQueryEnterResponseBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<HighPrecisionQueryEnterResponse> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<HighPrecisionQueryEnterResponse>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<HighPrecisionQueryEnterResponse> CreateHighPrecisionQueryEnterResponse(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    int32_t requestId = 0,
    com::nio::map::adas::flat::ResponseStatus status = com::nio::map::adas::flat::ResponseStatus_RESP_NOT_VALID,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::HighPrecisionMapPointList>>> highPrecisionMapPointList = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0)
{
    HighPrecisionQueryEnterResponseBuilder builder_(_fbb);
    builder_.add_message(message);
    builder_.add_highPrecisionMapPointList(highPrecisionMapPointList);
    builder_.add_status(status);
    builder_.add_requestId(requestId);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<HighPrecisionQueryEnterResponse> CreateHighPrecisionQueryEnterResponseDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    int32_t requestId = 0,
    com::nio::map::adas::flat::ResponseStatus status = com::nio::map::adas::flat::ResponseStatus_RESP_NOT_VALID,
    const std::vector<::flatbuffers::Offset<com::nio::map::adas::flat::HighPrecisionMapPointList>>* highPrecisionMapPointList = nullptr,
    const char* message = nullptr)
{
    auto highPrecisionMapPointList__ = highPrecisionMapPointList ? _fbb.CreateVector<::flatbuffers::Offset<com::nio::map::adas::flat::HighPrecisionMapPointList>>(*highPrecisionMapPointList) : 0;
    auto message__ = message ? _fbb.CreateString(message) : 0;
    return com::nio::map::adas::flat::CreateHighPrecisionQueryEnterResponse(
               _fbb,
               requestId,
               status,
               highPrecisionMapPointList__,
               message__);
}

struct NopInfoData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef NopInfoDataBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_NOPINFO_TYPE = 4,
        VT_NOPINFO = 6
    };
    com::nio::map::adas::flat::NopInfo nopInfo_type() const
    {
        return static_cast<com::nio::map::adas::flat::NopInfo>(GetField<uint8_t>(VT_NOPINFO_TYPE, 0));
    }
    const void* nopInfo() const
    {
        return GetPointer<const void*>(VT_NOPINFO);
    }
    const com::nio::map::adas::flat::HighPrecisionMapQueryRequest* nopInfo_as_highPrecisionMapQueryRequest() const
    {
        return nopInfo_type() == com::nio::map::adas::flat::NopInfo_highPrecisionMapQueryRequest ? static_cast<const com::nio::map::adas::flat::HighPrecisionMapQueryRequest*>(nopInfo()) : nullptr;
    }
    const com::nio::map::adas::flat::HighPrecisionMapQueryResponse* nopInfo_as_highPrecisionMapQueryResponse() const
    {
        return nopInfo_type() == com::nio::map::adas::flat::NopInfo_highPrecisionMapQueryResponse ? static_cast<const com::nio::map::adas::flat::HighPrecisionMapQueryResponse*>(nopInfo()) : nullptr;
    }
    const com::nio::map::adas::flat::HighPrecisionMapPointList* nopInfo_as_highPrecisionMapPointList() const
    {
        return nopInfo_type() == com::nio::map::adas::flat::NopInfo_highPrecisionMapPointList ? static_cast<const com::nio::map::adas::flat::HighPrecisionMapPointList*>(nopInfo()) : nullptr;
    }
    const com::nio::map::adas::flat::NowLocationHPMapStatus* nopInfo_as_nowLocationHPMapStatus() const
    {
        return nopInfo_type() == com::nio::map::adas::flat::NopInfo_nowLocationHPMapStatus ? static_cast<const com::nio::map::adas::flat::NowLocationHPMapStatus*>(nopInfo()) : nullptr;
    }
    const com::nio::map::adas::flat::HighPrecisionMapQueryRequest* nopInfo_as_highPrecisionQueryMapEnterRequest() const
    {
        return nopInfo_type() == com::nio::map::adas::flat::NopInfo_highPrecisionQueryMapEnterRequest ? static_cast<const com::nio::map::adas::flat::HighPrecisionMapQueryRequest*>(nopInfo()) : nullptr;
    }
    const com::nio::map::adas::flat::HighPrecisionQueryEnterResponse* nopInfo_as_highPrecisionQueryMapEnterResponse() const
    {
        return nopInfo_type() == com::nio::map::adas::flat::NopInfo_highPrecisionQueryMapEnterResponse ? static_cast<const com::nio::map::adas::flat::HighPrecisionQueryEnterResponse*>(nopInfo()) : nullptr;
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<uint8_t>(verifier, VT_NOPINFO_TYPE, 1) &&
               VerifyOffset(verifier, VT_NOPINFO) &&
               VerifyNopInfo(verifier, nopInfo(), nopInfo_type()) &&
               verifier.EndTable();
    }
};

struct NopInfoDataBuilder
{
    typedef NopInfoData Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_nopInfo_type(com::nio::map::adas::flat::NopInfo nopInfo_type)
    {
        fbb_.AddElement<uint8_t>(NopInfoData::VT_NOPINFO_TYPE, static_cast<uint8_t>(nopInfo_type), 0);
    }
    void add_nopInfo(::flatbuffers::Offset<void> nopInfo)
    {
        fbb_.AddOffset(NopInfoData::VT_NOPINFO, nopInfo);
    }
    explicit NopInfoDataBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<NopInfoData> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<NopInfoData>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<NopInfoData> CreateNopInfoData(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    com::nio::map::adas::flat::NopInfo nopInfo_type = com::nio::map::adas::flat::NopInfo_NONE,
    ::flatbuffers::Offset<void> nopInfo = 0)
{
    NopInfoDataBuilder builder_(_fbb);
    builder_.add_nopInfo(nopInfo);
    builder_.add_nopInfo_type(nopInfo_type);
    return builder_.Finish();
}

struct NodeInfoData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef NodeInfoDataBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_NODEINFO_TYPE = 4,
        VT_NODEINFO = 6
    };
    com::nio::map::adas::flat::NodeInfo nodeInfo_type() const
    {
        return static_cast<com::nio::map::adas::flat::NodeInfo>(GetField<uint8_t>(VT_NODEINFO_TYPE, 0));
    }
    const void* nodeInfo() const
    {
        return GetPointer<const void*>(VT_NODEINFO);
    }
    template<typename T> const T* nodeInfo_as() const;
    const com::nio::map::adas::flat::MapMatchInfo* nodeInfo_as_mapMatchInfo() const
    {
        return nodeInfo_type() == com::nio::map::adas::flat::NodeInfo_mapMatchInfo ? static_cast<const com::nio::map::adas::flat::MapMatchInfo*>(nodeInfo()) : nullptr;
    }
    const com::nio::map::adas::flat::SpeedLimitInfo* nodeInfo_as_speedLimitInfo() const
    {
        return nodeInfo_type() == com::nio::map::adas::flat::NodeInfo_speedLimitInfo ? static_cast<const com::nio::map::adas::flat::SpeedLimitInfo*>(nodeInfo()) : nullptr;
    }
    const com::nio::map::adas::flat::LaneInfo* nodeInfo_as_laneInfo() const
    {
        return nodeInfo_type() == com::nio::map::adas::flat::NodeInfo_laneInfo ? static_cast<const com::nio::map::adas::flat::LaneInfo*>(nodeInfo()) : nullptr;
    }
    const com::nio::map::adas::flat::TurnInfo* nodeInfo_as_turnInfo() const
    {
        return nodeInfo_type() == com::nio::map::adas::flat::NodeInfo_turnInfo ? static_cast<const com::nio::map::adas::flat::TurnInfo*>(nodeInfo()) : nullptr;
    }
    const com::nio::map::adas::flat::EnterNopRoadInfo* nodeInfo_as_enterNopRoadInfo() const
    {
        return nodeInfo_type() == com::nio::map::adas::flat::NodeInfo_enterNopRoadInfo ? static_cast<const com::nio::map::adas::flat::EnterNopRoadInfo*>(nodeInfo()) : nullptr;
    }
    const com::nio::map::adas::flat::ExitNopRoadInfo* nodeInfo_as_exitNopRoadInfo() const
    {
        return nodeInfo_type() == com::nio::map::adas::flat::NodeInfo_exitNopRoadInfo ? static_cast<const com::nio::map::adas::flat::ExitNopRoadInfo*>(nodeInfo()) : nullptr;
    }
    const com::nio::map::adas::flat::EnterNopRampInfo* nodeInfo_as_enterNopRampInfo() const
    {
        return nodeInfo_type() == com::nio::map::adas::flat::NodeInfo_enterNopRampInfo ? static_cast<const com::nio::map::adas::flat::EnterNopRampInfo*>(nodeInfo()) : nullptr;
    }
    const com::nio::map::adas::flat::HeartBeatInfo* nodeInfo_as_heartBeatInfo() const
    {
        return nodeInfo_type() == com::nio::map::adas::flat::NodeInfo_heartBeatInfo ? static_cast<const com::nio::map::adas::flat::HeartBeatInfo*>(nodeInfo()) : nullptr;
    }
    const com::nio::map::adas::flat::LaneInfoList* nodeInfo_as_laneInfoList() const
    {
        return nodeInfo_type() == com::nio::map::adas::flat::NodeInfo_laneInfoList ? static_cast<const com::nio::map::adas::flat::LaneInfoList*>(nodeInfo()) : nullptr;
    }
    const com::nio::map::adas::flat::ParallelRoad* nodeInfo_as_parallelRoad() const
    {
        return nodeInfo_type() == com::nio::map::adas::flat::NodeInfo_parallelRoad ? static_cast<const com::nio::map::adas::flat::ParallelRoad*>(nodeInfo()) : nullptr;
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<uint8_t>(verifier, VT_NODEINFO_TYPE, 1) &&
               VerifyOffset(verifier, VT_NODEINFO) &&
               VerifyNodeInfo(verifier, nodeInfo(), nodeInfo_type()) &&
               verifier.EndTable();
    }
};

template<> inline const com::nio::map::adas::flat::MapMatchInfo* NodeInfoData::nodeInfo_as<com::nio::map::adas::flat::MapMatchInfo>() const
{
    return nodeInfo_as_mapMatchInfo();
}

template<> inline const com::nio::map::adas::flat::SpeedLimitInfo* NodeInfoData::nodeInfo_as<com::nio::map::adas::flat::SpeedLimitInfo>() const
{
    return nodeInfo_as_speedLimitInfo();
}

template<> inline const com::nio::map::adas::flat::LaneInfo* NodeInfoData::nodeInfo_as<com::nio::map::adas::flat::LaneInfo>() const
{
    return nodeInfo_as_laneInfo();
}

template<> inline const com::nio::map::adas::flat::TurnInfo* NodeInfoData::nodeInfo_as<com::nio::map::adas::flat::TurnInfo>() const
{
    return nodeInfo_as_turnInfo();
}

template<> inline const com::nio::map::adas::flat::EnterNopRoadInfo* NodeInfoData::nodeInfo_as<com::nio::map::adas::flat::EnterNopRoadInfo>() const
{
    return nodeInfo_as_enterNopRoadInfo();
}

template<> inline const com::nio::map::adas::flat::ExitNopRoadInfo* NodeInfoData::nodeInfo_as<com::nio::map::adas::flat::ExitNopRoadInfo>() const
{
    return nodeInfo_as_exitNopRoadInfo();
}

template<> inline const com::nio::map::adas::flat::EnterNopRampInfo* NodeInfoData::nodeInfo_as<com::nio::map::adas::flat::EnterNopRampInfo>() const
{
    return nodeInfo_as_enterNopRampInfo();
}

template<> inline const com::nio::map::adas::flat::HeartBeatInfo* NodeInfoData::nodeInfo_as<com::nio::map::adas::flat::HeartBeatInfo>() const
{
    return nodeInfo_as_heartBeatInfo();
}

template<> inline const com::nio::map::adas::flat::LaneInfoList* NodeInfoData::nodeInfo_as<com::nio::map::adas::flat::LaneInfoList>() const
{
    return nodeInfo_as_laneInfoList();
}

template<> inline const com::nio::map::adas::flat::ParallelRoad* NodeInfoData::nodeInfo_as<com::nio::map::adas::flat::ParallelRoad>() const
{
    return nodeInfo_as_parallelRoad();
}

struct NodeInfoDataBuilder
{
    typedef NodeInfoData Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_nodeInfo_type(com::nio::map::adas::flat::NodeInfo nodeInfo_type)
    {
        fbb_.AddElement<uint8_t>(NodeInfoData::VT_NODEINFO_TYPE, static_cast<uint8_t>(nodeInfo_type), 0);
    }
    void add_nodeInfo(::flatbuffers::Offset<void> nodeInfo)
    {
        fbb_.AddOffset(NodeInfoData::VT_NODEINFO, nodeInfo);
    }
    explicit NodeInfoDataBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<NodeInfoData> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<NodeInfoData>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<NodeInfoData> CreateNodeInfoData(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    com::nio::map::adas::flat::NodeInfo nodeInfo_type = com::nio::map::adas::flat::NodeInfo_NONE,
    ::flatbuffers::Offset<void> nodeInfo = 0)
{
    NodeInfoDataBuilder builder_(_fbb);
    builder_.add_nodeInfo(nodeInfo);
    builder_.add_nodeInfo_type(nodeInfo_type);
    return builder_.Finish();
}

struct NavMapLoc FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef NavMapLocBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_EGOLOCAFTERMATCHING = 4
    };
    const com::nio::map::adas::flat::GPSLocation* egoLocAfterMatching() const
    {
        return GetPointer<const com::nio::map::adas::flat::GPSLocation*>(VT_EGOLOCAFTERMATCHING);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyOffset(verifier, VT_EGOLOCAFTERMATCHING) &&
               verifier.VerifyTable(egoLocAfterMatching()) &&
               verifier.EndTable();
    }
};

struct NavMapLocBuilder
{
    typedef NavMapLoc Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_egoLocAfterMatching(::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation> egoLocAfterMatching)
    {
        fbb_.AddOffset(NavMapLoc::VT_EGOLOCAFTERMATCHING, egoLocAfterMatching);
    }
    explicit NavMapLocBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<NavMapLoc> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<NavMapLoc>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<NavMapLoc> CreateNavMapLoc(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    ::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation> egoLocAfterMatching = 0)
{
    NavMapLocBuilder builder_(_fbb);
    builder_.add_egoLocAfterMatching(egoLocAfterMatching);
    return builder_.Finish();
}

struct NavMapLocVersion2 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef NavMapLocVersion2Builder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_EGOLOCAFTERMATCHING = 4,
        VT_ANGLE = 6,
        VT_DISTANCE = 8,
        VT_ROADNAME = 10,
        VT_USEDROADNAME = 12,
        VT_EROADNAME = 14,
        VT_LINKLENGTH = 16,
        VT_LINKID = 18,
        VT_SPEEDLIMIT = 20,
        VT_FORMOFWAY = 22,
        VT_MATCHSTATE = 24,
        VT_ROADCLASS = 26,
        VT_TIMESTAMP = 28,
        VT_LAST_ROUTE_CHANGE_TIMESTAMP = 30,
        VT_LAST_ROUTE_COUNT = 32,
        VT_LINK_REMAIN_DIST = 34,
        VT_LINKINDEX = 36
    };
    const com::nio::map::adas::flat::GPSLocation* egoLocAfterMatching() const
    {
        return GetPointer<const com::nio::map::adas::flat::GPSLocation*>(VT_EGOLOCAFTERMATCHING);
    }
    float angle() const
    {
        return GetField<float>(VT_ANGLE, 0.0f);
    }
    int32_t distance() const
    {
        return GetField<int32_t>(VT_DISTANCE, 0);
    }
    const ::flatbuffers::String* roadName() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_ROADNAME);
    }
    const ::flatbuffers::String* usedRoadName() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_USEDROADNAME);
    }
    const ::flatbuffers::String* eRoadName() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_EROADNAME);
    }
    double linkLength() const
    {
        return GetField<double>(VT_LINKLENGTH, 0.0);
    }
    uint64_t linkId() const
    {
        return GetField<uint64_t>(VT_LINKID, 0);
    }
    int32_t speedLimit() const
    {
        return GetField<int32_t>(VT_SPEEDLIMIT, 0);
    }
    int32_t formOfWay() const
    {
        return GetField<int32_t>(VT_FORMOFWAY, 0);
    }
    int32_t matchState() const
    {
        return GetField<int32_t>(VT_MATCHSTATE, 0);
    }
    com::nio::map::adas::flat::RoadClass roadClass() const
    {
        return static_cast<com::nio::map::adas::flat::RoadClass>(GetField<int32_t>(VT_ROADCLASS, 0));
    }
    uint64_t timestamp() const
    {
        return GetField<uint64_t>(VT_TIMESTAMP, 0);
    }
    uint64_t last_route_change_timestamp() const
    {
        return GetField<uint64_t>(VT_LAST_ROUTE_CHANGE_TIMESTAMP, 0);
    }
    int32_t last_route_count() const
    {
        return GetField<int32_t>(VT_LAST_ROUTE_COUNT, 0);
    }
    float link_remain_dist() const
    {
        return GetField<float>(VT_LINK_REMAIN_DIST, 0.0f);
    }
    int32_t linkIndex() const
    {
        return GetField<int32_t>(VT_LINKINDEX, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyOffset(verifier, VT_EGOLOCAFTERMATCHING) &&
               verifier.VerifyTable(egoLocAfterMatching()) &&
               VerifyField<float>(verifier, VT_ANGLE, 4) &&
               VerifyField<int32_t>(verifier, VT_DISTANCE, 4) &&
               VerifyOffset(verifier, VT_ROADNAME) &&
               verifier.VerifyString(roadName()) &&
               VerifyOffset(verifier, VT_USEDROADNAME) &&
               verifier.VerifyString(usedRoadName()) &&
               VerifyOffset(verifier, VT_EROADNAME) &&
               verifier.VerifyString(eRoadName()) &&
               VerifyField<double>(verifier, VT_LINKLENGTH, 8) &&
               VerifyField<uint64_t>(verifier, VT_LINKID, 8) &&
               VerifyField<int32_t>(verifier, VT_SPEEDLIMIT, 4) &&
               VerifyField<int32_t>(verifier, VT_FORMOFWAY, 4) &&
               VerifyField<int32_t>(verifier, VT_MATCHSTATE, 4) &&
               VerifyField<int32_t>(verifier, VT_ROADCLASS, 4) &&
               VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
               VerifyField<uint64_t>(verifier, VT_LAST_ROUTE_CHANGE_TIMESTAMP, 8) &&
               VerifyField<int32_t>(verifier, VT_LAST_ROUTE_COUNT, 4) &&
               VerifyField<float>(verifier, VT_LINK_REMAIN_DIST, 4) &&
               VerifyField<int32_t>(verifier, VT_LINKINDEX, 4) &&
               verifier.EndTable();
    }
};

struct NavMapLocVersion2Builder
{
    typedef NavMapLocVersion2 Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_egoLocAfterMatching(::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation> egoLocAfterMatching)
    {
        fbb_.AddOffset(NavMapLocVersion2::VT_EGOLOCAFTERMATCHING, egoLocAfterMatching);
    }
    void add_angle(float angle)
    {
        fbb_.AddElement<float>(NavMapLocVersion2::VT_ANGLE, angle, 0.0f);
    }
    void add_distance(int32_t distance)
    {
        fbb_.AddElement<int32_t>(NavMapLocVersion2::VT_DISTANCE, distance, 0);
    }
    void add_roadName(::flatbuffers::Offset<::flatbuffers::String> roadName)
    {
        fbb_.AddOffset(NavMapLocVersion2::VT_ROADNAME, roadName);
    }
    void add_usedRoadName(::flatbuffers::Offset<::flatbuffers::String> usedRoadName)
    {
        fbb_.AddOffset(NavMapLocVersion2::VT_USEDROADNAME, usedRoadName);
    }
    void add_eRoadName(::flatbuffers::Offset<::flatbuffers::String> eRoadName)
    {
        fbb_.AddOffset(NavMapLocVersion2::VT_EROADNAME, eRoadName);
    }
    void add_linkLength(double linkLength)
    {
        fbb_.AddElement<double>(NavMapLocVersion2::VT_LINKLENGTH, linkLength, 0.0);
    }
    void add_linkId(uint64_t linkId)
    {
        fbb_.AddElement<uint64_t>(NavMapLocVersion2::VT_LINKID, linkId, 0);
    }
    void add_speedLimit(int32_t speedLimit)
    {
        fbb_.AddElement<int32_t>(NavMapLocVersion2::VT_SPEEDLIMIT, speedLimit, 0);
    }
    void add_formOfWay(int32_t formOfWay)
    {
        fbb_.AddElement<int32_t>(NavMapLocVersion2::VT_FORMOFWAY, formOfWay, 0);
    }
    void add_matchState(int32_t matchState)
    {
        fbb_.AddElement<int32_t>(NavMapLocVersion2::VT_MATCHSTATE, matchState, 0);
    }
    void add_roadClass(com::nio::map::adas::flat::RoadClass roadClass)
    {
        fbb_.AddElement<int32_t>(NavMapLocVersion2::VT_ROADCLASS, static_cast<int32_t>(roadClass), 0);
    }
    void add_timestamp(uint64_t timestamp)
    {
        fbb_.AddElement<uint64_t>(NavMapLocVersion2::VT_TIMESTAMP, timestamp, 0);
    }
    void add_last_route_change_timestamp(uint64_t last_route_change_timestamp)
    {
        fbb_.AddElement<uint64_t>(NavMapLocVersion2::VT_LAST_ROUTE_CHANGE_TIMESTAMP, last_route_change_timestamp, 0);
    }
    void add_last_route_count(int32_t last_route_count)
    {
        fbb_.AddElement<int32_t>(NavMapLocVersion2::VT_LAST_ROUTE_COUNT, last_route_count, 0);
    }
    void add_link_remain_dist(float link_remain_dist)
    {
        fbb_.AddElement<float>(NavMapLocVersion2::VT_LINK_REMAIN_DIST, link_remain_dist, 0.0f);
    }
    void add_linkIndex(int32_t linkIndex)
    {
        fbb_.AddElement<int32_t>(NavMapLocVersion2::VT_LINKINDEX, linkIndex, 0);
    }
    explicit NavMapLocVersion2Builder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<NavMapLocVersion2> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<NavMapLocVersion2>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<NavMapLocVersion2> CreateNavMapLocVersion2(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    ::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation> egoLocAfterMatching = 0,
    float angle = 0.0f,
    int32_t distance = 0,
    ::flatbuffers::Offset<::flatbuffers::String> roadName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> usedRoadName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> eRoadName = 0,
    double linkLength = 0.0,
    uint64_t linkId = 0,
    int32_t speedLimit = 0,
    int32_t formOfWay = 0,
    int32_t matchState = 0,
    com::nio::map::adas::flat::RoadClass roadClass = com::nio::map::adas::flat::RoadClass_R_NONE,
    uint64_t timestamp = 0,
    uint64_t last_route_change_timestamp = 0,
    int32_t last_route_count = 0,
    float link_remain_dist = 0.0f,
    int32_t linkIndex = 0)
{
    NavMapLocVersion2Builder builder_(_fbb);
    builder_.add_last_route_change_timestamp(last_route_change_timestamp);
    builder_.add_timestamp(timestamp);
    builder_.add_linkId(linkId);
    builder_.add_linkLength(linkLength);
    builder_.add_linkIndex(linkIndex);
    builder_.add_link_remain_dist(link_remain_dist);
    builder_.add_last_route_count(last_route_count);
    builder_.add_roadClass(roadClass);
    builder_.add_matchState(matchState);
    builder_.add_formOfWay(formOfWay);
    builder_.add_speedLimit(speedLimit);
    builder_.add_eRoadName(eRoadName);
    builder_.add_usedRoadName(usedRoadName);
    builder_.add_roadName(roadName);
    builder_.add_distance(distance);
    builder_.add_angle(angle);
    builder_.add_egoLocAfterMatching(egoLocAfterMatching);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<NavMapLocVersion2> CreateNavMapLocVersion2Direct(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    ::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation> egoLocAfterMatching = 0,
    float angle = 0.0f,
    int32_t distance = 0,
    const char* roadName = nullptr,
    const char* usedRoadName = nullptr,
    const char* eRoadName = nullptr,
    double linkLength = 0.0,
    uint64_t linkId = 0,
    int32_t speedLimit = 0,
    int32_t formOfWay = 0,
    int32_t matchState = 0,
    com::nio::map::adas::flat::RoadClass roadClass = com::nio::map::adas::flat::RoadClass_R_NONE,
    uint64_t timestamp = 0,
    uint64_t last_route_change_timestamp = 0,
    int32_t last_route_count = 0,
    float link_remain_dist = 0.0f,
    int32_t linkIndex = 0)
{
    auto roadName__ = roadName ? _fbb.CreateString(roadName) : 0;
    auto usedRoadName__ = usedRoadName ? _fbb.CreateString(usedRoadName) : 0;
    auto eRoadName__ = eRoadName ? _fbb.CreateString(eRoadName) : 0;
    return com::nio::map::adas::flat::CreateNavMapLocVersion2(
               _fbb,
               egoLocAfterMatching,
               angle,
               distance,
               roadName__,
               usedRoadName__,
               eRoadName__,
               linkLength,
               linkId,
               speedLimit,
               formOfWay,
               matchState,
               roadClass,
               timestamp,
               last_route_change_timestamp,
               last_route_count,
               link_remain_dist,
               linkIndex);
}

struct RouteMatchRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef RouteMatchRequestBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_REQUEST_ID = 4,
        VT_LINK_LIST = 6,
        VT_REQUEST_TYPE = 8,
        VT_ROUTE_CHANGE_REASON = 10,
        VT_TIMESTAMP = 12,
        VT_REQUEST_COUNT = 14,
        VT_SD_SOURCE_INFO = 16,
        VT_ROUTE_ID = 18,
        VT_VENDOR = 20,
        VT_NOP_ENABLE = 22,
        VT_TBT_SEGMENT_ACTION_LIST = 24,
        VT_NAD_ENABLE = 26,
        VT_TRAFFICLIGHTCOUNT = 28,
        VT_TRAVELTIME = 30,
        VT_TOLLCOST = 32,
        VT_LENGTH = 34
    };
    const ::flatbuffers::String* request_id() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_REQUEST_ID);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::SDLinkInfo>>* link_list() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::SDLinkInfo>> *>(VT_LINK_LIST);
    }
    int32_t request_type() const
    {
        return GetField<int32_t>(VT_REQUEST_TYPE, 0);
    }
    int32_t route_change_reason() const
    {
        return GetField<int32_t>(VT_ROUTE_CHANGE_REASON, 0);
    }
    uint64_t timestamp() const
    {
        return GetField<uint64_t>(VT_TIMESTAMP, 0);
    }
    int32_t request_count() const
    {
        return GetField<int32_t>(VT_REQUEST_COUNT, 0);
    }
    int32_t sd_source_info() const
    {
        return GetField<int32_t>(VT_SD_SOURCE_INFO, 0);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>* route_id() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ROUTE_ID);
    }
    const ::flatbuffers::String* vendor() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_VENDOR);
    }
    bool nop_enable() const
    {
        return GetField<uint8_t>(VT_NOP_ENABLE, 1) != 0;
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::TBTSegmentAction>>* tbt_segment_action_list() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::TBTSegmentAction>> *>(VT_TBT_SEGMENT_ACTION_LIST);
    }
    int32_t nad_enable() const
    {
        return GetField<int32_t>(VT_NAD_ENABLE, 0);
    }
    int32_t trafficLightCount() const
    {
        return GetField<int32_t>(VT_TRAFFICLIGHTCOUNT, 0);
    }
    int32_t travelTime() const
    {
        return GetField<int32_t>(VT_TRAVELTIME, 0);
    }
    int32_t tollCost() const
    {
        return GetField<int32_t>(VT_TOLLCOST, 0);
    }
    int32_t length() const
    {
        return GetField<int32_t>(VT_LENGTH, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyOffset(verifier, VT_REQUEST_ID) &&
               verifier.VerifyString(request_id()) &&
               VerifyOffset(verifier, VT_LINK_LIST) &&
               verifier.VerifyVector(link_list()) &&
               verifier.VerifyVectorOfTables(link_list()) &&
               VerifyField<int32_t>(verifier, VT_REQUEST_TYPE, 4) &&
               VerifyField<int32_t>(verifier, VT_ROUTE_CHANGE_REASON, 4) &&
               VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
               VerifyField<int32_t>(verifier, VT_REQUEST_COUNT, 4) &&
               VerifyField<int32_t>(verifier, VT_SD_SOURCE_INFO, 4) &&
               VerifyOffset(verifier, VT_ROUTE_ID) &&
               verifier.VerifyVector(route_id()) &&
               verifier.VerifyVectorOfStrings(route_id()) &&
               VerifyOffset(verifier, VT_VENDOR) &&
               verifier.VerifyString(vendor()) &&
               VerifyField<uint8_t>(verifier, VT_NOP_ENABLE, 1) &&
               VerifyOffset(verifier, VT_TBT_SEGMENT_ACTION_LIST) &&
               verifier.VerifyVector(tbt_segment_action_list()) &&
               verifier.VerifyVectorOfTables(tbt_segment_action_list()) &&
               VerifyField<int32_t>(verifier, VT_NAD_ENABLE, 4) &&
               VerifyField<int32_t>(verifier, VT_TRAFFICLIGHTCOUNT, 4) &&
               VerifyField<int32_t>(verifier, VT_TRAVELTIME, 4) &&
               VerifyField<int32_t>(verifier, VT_TOLLCOST, 4) &&
               VerifyField<int32_t>(verifier, VT_LENGTH, 4) &&
               verifier.EndTable();
    }
};

struct RouteMatchRequestBuilder
{
    typedef RouteMatchRequest Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_request_id(::flatbuffers::Offset<::flatbuffers::String> request_id)
    {
        fbb_.AddOffset(RouteMatchRequest::VT_REQUEST_ID, request_id);
    }
    void add_link_list(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::SDLinkInfo>>> link_list)
    {
        fbb_.AddOffset(RouteMatchRequest::VT_LINK_LIST, link_list);
    }
    void add_request_type(int32_t request_type)
    {
        fbb_.AddElement<int32_t>(RouteMatchRequest::VT_REQUEST_TYPE, request_type, 0);
    }
    void add_route_change_reason(int32_t route_change_reason)
    {
        fbb_.AddElement<int32_t>(RouteMatchRequest::VT_ROUTE_CHANGE_REASON, route_change_reason, 0);
    }
    void add_timestamp(uint64_t timestamp)
    {
        fbb_.AddElement<uint64_t>(RouteMatchRequest::VT_TIMESTAMP, timestamp, 0);
    }
    void add_request_count(int32_t request_count)
    {
        fbb_.AddElement<int32_t>(RouteMatchRequest::VT_REQUEST_COUNT, request_count, 0);
    }
    void add_sd_source_info(int32_t sd_source_info)
    {
        fbb_.AddElement<int32_t>(RouteMatchRequest::VT_SD_SOURCE_INFO, sd_source_info, 0);
    }
    void add_route_id(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> route_id)
    {
        fbb_.AddOffset(RouteMatchRequest::VT_ROUTE_ID, route_id);
    }
    void add_vendor(::flatbuffers::Offset<::flatbuffers::String> vendor)
    {
        fbb_.AddOffset(RouteMatchRequest::VT_VENDOR, vendor);
    }
    void add_nop_enable(bool nop_enable)
    {
        fbb_.AddElement<uint8_t>(RouteMatchRequest::VT_NOP_ENABLE, static_cast<uint8_t>(nop_enable), 1);
    }
    void add_tbt_segment_action_list(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::TBTSegmentAction>>> tbt_segment_action_list)
    {
        fbb_.AddOffset(RouteMatchRequest::VT_TBT_SEGMENT_ACTION_LIST, tbt_segment_action_list);
    }
    void add_nad_enable(int32_t nad_enable)
    {
        fbb_.AddElement<int32_t>(RouteMatchRequest::VT_NAD_ENABLE, nad_enable, 0);
    }
    void add_trafficLightCount(int32_t trafficLightCount)
    {
        fbb_.AddElement<int32_t>(RouteMatchRequest::VT_TRAFFICLIGHTCOUNT, trafficLightCount, 0);
    }
    void add_travelTime(int32_t travelTime)
    {
        fbb_.AddElement<int32_t>(RouteMatchRequest::VT_TRAVELTIME, travelTime, 0);
    }
    void add_tollCost(int32_t tollCost)
    {
        fbb_.AddElement<int32_t>(RouteMatchRequest::VT_TOLLCOST, tollCost, 0);
    }
    void add_length(int32_t length)
    {
        fbb_.AddElement<int32_t>(RouteMatchRequest::VT_LENGTH, length, 0);
    }
    explicit RouteMatchRequestBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<RouteMatchRequest> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<RouteMatchRequest>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<RouteMatchRequest> CreateRouteMatchRequest(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    ::flatbuffers::Offset<::flatbuffers::String> request_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::SDLinkInfo>>> link_list = 0,
    int32_t request_type = 0,
    int32_t route_change_reason = 0,
    uint64_t timestamp = 0,
    int32_t request_count = 0,
    int32_t sd_source_info = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> route_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> vendor = 0,
    bool nop_enable = true,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::TBTSegmentAction>>> tbt_segment_action_list = 0,
    int32_t nad_enable = 0,
    int32_t trafficLightCount = 0,
    int32_t travelTime = 0,
    int32_t tollCost = 0,
    int32_t length = 0)
{
    RouteMatchRequestBuilder builder_(_fbb);
    builder_.add_timestamp(timestamp);
    builder_.add_length(length);
    builder_.add_tollCost(tollCost);
    builder_.add_travelTime(travelTime);
    builder_.add_trafficLightCount(trafficLightCount);
    builder_.add_nad_enable(nad_enable);
    builder_.add_tbt_segment_action_list(tbt_segment_action_list);
    builder_.add_vendor(vendor);
    builder_.add_route_id(route_id);
    builder_.add_sd_source_info(sd_source_info);
    builder_.add_request_count(request_count);
    builder_.add_route_change_reason(route_change_reason);
    builder_.add_request_type(request_type);
    builder_.add_link_list(link_list);
    builder_.add_request_id(request_id);
    builder_.add_nop_enable(nop_enable);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<RouteMatchRequest> CreateRouteMatchRequestDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    const char* request_id = nullptr,
    const std::vector<::flatbuffers::Offset<com::nio::map::adas::flat::SDLinkInfo>>* link_list = nullptr,
    int32_t request_type = 0,
    int32_t route_change_reason = 0,
    uint64_t timestamp = 0,
    int32_t request_count = 0,
    int32_t sd_source_info = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>>* route_id = nullptr,
    const char* vendor = nullptr,
    bool nop_enable = true,
    const std::vector<::flatbuffers::Offset<com::nio::map::adas::flat::TBTSegmentAction>>* tbt_segment_action_list = nullptr,
    int32_t nad_enable = 0,
    int32_t trafficLightCount = 0,
    int32_t travelTime = 0,
    int32_t tollCost = 0,
    int32_t length = 0)
{
    auto request_id__ = request_id ? _fbb.CreateString(request_id) : 0;
    auto link_list__ = link_list ? _fbb.CreateVector<::flatbuffers::Offset<com::nio::map::adas::flat::SDLinkInfo>>(*link_list) : 0;
    auto route_id__ = route_id ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*route_id) : 0;
    auto vendor__ = vendor ? _fbb.CreateString(vendor) : 0;
    auto tbt_segment_action_list__ = tbt_segment_action_list ? _fbb.CreateVector<::flatbuffers::Offset<com::nio::map::adas::flat::TBTSegmentAction>>(*tbt_segment_action_list) : 0;
    return com::nio::map::adas::flat::CreateRouteMatchRequest(
               _fbb,
               request_id__,
               link_list__,
               request_type,
               route_change_reason,
               timestamp,
               request_count,
               sd_source_info,
               route_id__,
               vendor__,
               nop_enable,
               tbt_segment_action_list__,
               nad_enable,
               trafficLightCount,
               travelTime,
               tollCost,
               length);
}

struct TBTSegmentAction FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef TBTSegmentActionBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_MAIN_ACTION = 4,
        VT_ASSISTANT_ACTION = 6,
        VT_LINK_COUNT = 8
    };
    int32_t main_action() const
    {
        return GetField<int32_t>(VT_MAIN_ACTION, 0);
    }
    int32_t assistant_action() const
    {
        return GetField<int32_t>(VT_ASSISTANT_ACTION, 0);
    }
    int32_t link_count() const
    {
        return GetField<int32_t>(VT_LINK_COUNT, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<int32_t>(verifier, VT_MAIN_ACTION, 4) &&
               VerifyField<int32_t>(verifier, VT_ASSISTANT_ACTION, 4) &&
               VerifyField<int32_t>(verifier, VT_LINK_COUNT, 4) &&
               verifier.EndTable();
    }
};

struct TBTSegmentActionBuilder
{
    typedef TBTSegmentAction Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_main_action(int32_t main_action)
    {
        fbb_.AddElement<int32_t>(TBTSegmentAction::VT_MAIN_ACTION, main_action, 0);
    }
    void add_assistant_action(int32_t assistant_action)
    {
        fbb_.AddElement<int32_t>(TBTSegmentAction::VT_ASSISTANT_ACTION, assistant_action, 0);
    }
    void add_link_count(int32_t link_count)
    {
        fbb_.AddElement<int32_t>(TBTSegmentAction::VT_LINK_COUNT, link_count, 0);
    }
    explicit TBTSegmentActionBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<TBTSegmentAction> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<TBTSegmentAction>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<TBTSegmentAction> CreateTBTSegmentAction(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    int32_t main_action = 0,
    int32_t assistant_action = 0,
    int32_t link_count = 0)
{
    TBTSegmentActionBuilder builder_(_fbb);
    builder_.add_link_count(link_count);
    builder_.add_assistant_action(assistant_action);
    builder_.add_main_action(main_action);
    return builder_.Finish();
}

struct SearchByRoadNameRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef SearchByRoadNameRequestBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_ROAD_NAME = 4,
        VT_SEARCH_RADIUS = 6,
        VT_CENTER_LAT = 8,
        VT_CENTER_LON = 10,
        VT_MAX_COUNT = 12
    };
    const ::flatbuffers::String* road_name() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_ROAD_NAME);
    }
    int32_t search_radius() const
    {
        return GetField<int32_t>(VT_SEARCH_RADIUS, 0);
    }
    double center_lat() const
    {
        return GetField<double>(VT_CENTER_LAT, 0.0);
    }
    double center_lon() const
    {
        return GetField<double>(VT_CENTER_LON, 0.0);
    }
    int32_t max_count() const
    {
        return GetField<int32_t>(VT_MAX_COUNT, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyOffset(verifier, VT_ROAD_NAME) &&
               verifier.VerifyString(road_name()) &&
               VerifyField<int32_t>(verifier, VT_SEARCH_RADIUS, 4) &&
               VerifyField<double>(verifier, VT_CENTER_LAT, 8) &&
               VerifyField<double>(verifier, VT_CENTER_LON, 8) &&
               VerifyField<int32_t>(verifier, VT_MAX_COUNT, 4) &&
               verifier.EndTable();
    }
};

struct SearchByRoadNameRequestBuilder
{
    typedef SearchByRoadNameRequest Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_road_name(::flatbuffers::Offset<::flatbuffers::String> road_name)
    {
        fbb_.AddOffset(SearchByRoadNameRequest::VT_ROAD_NAME, road_name);
    }
    void add_search_radius(int32_t search_radius)
    {
        fbb_.AddElement<int32_t>(SearchByRoadNameRequest::VT_SEARCH_RADIUS, search_radius, 0);
    }
    void add_center_lat(double center_lat)
    {
        fbb_.AddElement<double>(SearchByRoadNameRequest::VT_CENTER_LAT, center_lat, 0.0);
    }
    void add_center_lon(double center_lon)
    {
        fbb_.AddElement<double>(SearchByRoadNameRequest::VT_CENTER_LON, center_lon, 0.0);
    }
    void add_max_count(int32_t max_count)
    {
        fbb_.AddElement<int32_t>(SearchByRoadNameRequest::VT_MAX_COUNT, max_count, 0);
    }
    explicit SearchByRoadNameRequestBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<SearchByRoadNameRequest> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<SearchByRoadNameRequest>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<SearchByRoadNameRequest> CreateSearchByRoadNameRequest(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    ::flatbuffers::Offset<::flatbuffers::String> road_name = 0,
    int32_t search_radius = 0,
    double center_lat = 0.0,
    double center_lon = 0.0,
    int32_t max_count = 0)
{
    SearchByRoadNameRequestBuilder builder_(_fbb);
    builder_.add_center_lon(center_lon);
    builder_.add_center_lat(center_lat);
    builder_.add_max_count(max_count);
    builder_.add_search_radius(search_radius);
    builder_.add_road_name(road_name);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<SearchByRoadNameRequest> CreateSearchByRoadNameRequestDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    const char* road_name = nullptr,
    int32_t search_radius = 0,
    double center_lat = 0.0,
    double center_lon = 0.0,
    int32_t max_count = 0)
{
    auto road_name__ = road_name ? _fbb.CreateString(road_name) : 0;
    return com::nio::map::adas::flat::CreateSearchByRoadNameRequest(
               _fbb,
               road_name__,
               search_radius,
               center_lat,
               center_lon,
               max_count);
}

struct SDLinkInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef SDLinkInfoBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_LINKID = 4,
        VT_DATA_VERSION = 6,
        VT_SHAPE_POINTS = 8,
        VT_LINK_LENGTH = 10,
        VT_ROAD_CLASS = 12,
        VT_ROAD_NAME = 14,
        VT_IS_OVERHEAD = 16,
        VT_HAS_PARALLEL = 18,
        VT_HAS_MULTIOUT = 20,
        VT_HAS_MIXFORK = 22,
        VT_FORMWAY = 24,
        VT_LINK_DIRECT = 26,
        VT_ORIGIN_ROAD_CLASS = 28,
        VT_IS_TOLL = 30,
        VT_ORIGIN_FORMWAY = 32,
        VT_LANE_NUM = 34,
        VT_SPEED_LIMIT = 36,
        VT_HISTORY_SPEED = 38,
        VT_TRAVELTIME = 40
    };
    uint64_t linkid() const
    {
        return GetField<uint64_t>(VT_LINKID, 0);
    }
    uint64_t data_version() const
    {
        return GetField<uint64_t>(VT_DATA_VERSION, 0);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation>>* shape_points() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation>> *>(VT_SHAPE_POINTS);
    }
    int32_t link_length() const
    {
        return GetField<int32_t>(VT_LINK_LENGTH, 0);
    }
    com::nio::map::adas::flat::RoadClass road_class() const
    {
        return static_cast<com::nio::map::adas::flat::RoadClass>(GetField<int32_t>(VT_ROAD_CLASS, 0));
    }
    const ::flatbuffers::String* road_name() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_ROAD_NAME);
    }
    bool is_overhead() const
    {
        return GetField<uint8_t>(VT_IS_OVERHEAD, 0) != 0;
    }
    bool has_parallel() const
    {
        return GetField<uint8_t>(VT_HAS_PARALLEL, 0) != 0;
    }
    bool has_multiout() const
    {
        return GetField<uint8_t>(VT_HAS_MULTIOUT, 0) != 0;
    }
    bool has_mixfork() const
    {
        return GetField<uint8_t>(VT_HAS_MIXFORK, 0) != 0;
    }
    int32_t formway() const
    {
        return GetField<int32_t>(VT_FORMWAY, 0);
    }
    int32_t link_direct() const
    {
        return GetField<int32_t>(VT_LINK_DIRECT, 0);
    }
    int32_t origin_road_class() const
    {
        return GetField<int32_t>(VT_ORIGIN_ROAD_CLASS, 0);
    }
    bool is_toll() const
    {
        return GetField<uint8_t>(VT_IS_TOLL, 0) != 0;
    }
    const ::flatbuffers::Vector<int32_t>* origin_formway() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_ORIGIN_FORMWAY);
    }
    int32_t lane_num() const
    {
        return GetField<int32_t>(VT_LANE_NUM, 0);
    }
    int32_t speed_limit() const
    {
        return GetField<int32_t>(VT_SPEED_LIMIT, 0);
    }
    int32_t history_speed() const
    {
        return GetField<int32_t>(VT_HISTORY_SPEED, 0);
    }
    int32_t travelTime() const
    {
        return GetField<int32_t>(VT_TRAVELTIME, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<uint64_t>(verifier, VT_LINKID, 8) &&
               VerifyField<uint64_t>(verifier, VT_DATA_VERSION, 8) &&
               VerifyOffset(verifier, VT_SHAPE_POINTS) &&
               verifier.VerifyVector(shape_points()) &&
               verifier.VerifyVectorOfTables(shape_points()) &&
               VerifyField<int32_t>(verifier, VT_LINK_LENGTH, 4) &&
               VerifyField<int32_t>(verifier, VT_ROAD_CLASS, 4) &&
               VerifyOffset(verifier, VT_ROAD_NAME) &&
               verifier.VerifyString(road_name()) &&
               VerifyField<uint8_t>(verifier, VT_IS_OVERHEAD, 1) &&
               VerifyField<uint8_t>(verifier, VT_HAS_PARALLEL, 1) &&
               VerifyField<uint8_t>(verifier, VT_HAS_MULTIOUT, 1) &&
               VerifyField<uint8_t>(verifier, VT_HAS_MIXFORK, 1) &&
               VerifyField<int32_t>(verifier, VT_FORMWAY, 4) &&
               VerifyField<int32_t>(verifier, VT_LINK_DIRECT, 4) &&
               VerifyField<int32_t>(verifier, VT_ORIGIN_ROAD_CLASS, 4) &&
               VerifyField<uint8_t>(verifier, VT_IS_TOLL, 1) &&
               VerifyOffset(verifier, VT_ORIGIN_FORMWAY) &&
               verifier.VerifyVector(origin_formway()) &&
               VerifyField<int32_t>(verifier, VT_LANE_NUM, 4) &&
               VerifyField<int32_t>(verifier, VT_SPEED_LIMIT, 4) &&
               VerifyField<int32_t>(verifier, VT_HISTORY_SPEED, 4) &&
               VerifyField<int32_t>(verifier, VT_TRAVELTIME, 4) &&
               verifier.EndTable();
    }
};

struct SDLinkInfoBuilder
{
    typedef SDLinkInfo Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_linkid(uint64_t linkid)
    {
        fbb_.AddElement<uint64_t>(SDLinkInfo::VT_LINKID, linkid, 0);
    }
    void add_data_version(uint64_t data_version)
    {
        fbb_.AddElement<uint64_t>(SDLinkInfo::VT_DATA_VERSION, data_version, 0);
    }
    void add_shape_points(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation>>> shape_points)
    {
        fbb_.AddOffset(SDLinkInfo::VT_SHAPE_POINTS, shape_points);
    }
    void add_link_length(int32_t link_length)
    {
        fbb_.AddElement<int32_t>(SDLinkInfo::VT_LINK_LENGTH, link_length, 0);
    }
    void add_road_class(com::nio::map::adas::flat::RoadClass road_class)
    {
        fbb_.AddElement<int32_t>(SDLinkInfo::VT_ROAD_CLASS, static_cast<int32_t>(road_class), 0);
    }
    void add_road_name(::flatbuffers::Offset<::flatbuffers::String> road_name)
    {
        fbb_.AddOffset(SDLinkInfo::VT_ROAD_NAME, road_name);
    }
    void add_is_overhead(bool is_overhead)
    {
        fbb_.AddElement<uint8_t>(SDLinkInfo::VT_IS_OVERHEAD, static_cast<uint8_t>(is_overhead), 0);
    }
    void add_has_parallel(bool has_parallel)
    {
        fbb_.AddElement<uint8_t>(SDLinkInfo::VT_HAS_PARALLEL, static_cast<uint8_t>(has_parallel), 0);
    }
    void add_has_multiout(bool has_multiout)
    {
        fbb_.AddElement<uint8_t>(SDLinkInfo::VT_HAS_MULTIOUT, static_cast<uint8_t>(has_multiout), 0);
    }
    void add_has_mixfork(bool has_mixfork)
    {
        fbb_.AddElement<uint8_t>(SDLinkInfo::VT_HAS_MIXFORK, static_cast<uint8_t>(has_mixfork), 0);
    }
    void add_formway(int32_t formway)
    {
        fbb_.AddElement<int32_t>(SDLinkInfo::VT_FORMWAY, formway, 0);
    }
    void add_link_direct(int32_t link_direct)
    {
        fbb_.AddElement<int32_t>(SDLinkInfo::VT_LINK_DIRECT, link_direct, 0);
    }
    void add_origin_road_class(int32_t origin_road_class)
    {
        fbb_.AddElement<int32_t>(SDLinkInfo::VT_ORIGIN_ROAD_CLASS, origin_road_class, 0);
    }
    void add_is_toll(bool is_toll)
    {
        fbb_.AddElement<uint8_t>(SDLinkInfo::VT_IS_TOLL, static_cast<uint8_t>(is_toll), 0);
    }
    void add_origin_formway(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> origin_formway)
    {
        fbb_.AddOffset(SDLinkInfo::VT_ORIGIN_FORMWAY, origin_formway);
    }
    void add_lane_num(int32_t lane_num)
    {
        fbb_.AddElement<int32_t>(SDLinkInfo::VT_LANE_NUM, lane_num, 0);
    }
    void add_speed_limit(int32_t speed_limit)
    {
        fbb_.AddElement<int32_t>(SDLinkInfo::VT_SPEED_LIMIT, speed_limit, 0);
    }
    void add_history_speed(int32_t history_speed)
    {
        fbb_.AddElement<int32_t>(SDLinkInfo::VT_HISTORY_SPEED, history_speed, 0);
    }
    void add_travelTime(int32_t travelTime)
    {
        fbb_.AddElement<int32_t>(SDLinkInfo::VT_TRAVELTIME, travelTime, 0);
    }
    explicit SDLinkInfoBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<SDLinkInfo> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<SDLinkInfo>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<SDLinkInfo> CreateSDLinkInfo(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    uint64_t linkid = 0,
    uint64_t data_version = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation>>> shape_points = 0,
    int32_t link_length = 0,
    com::nio::map::adas::flat::RoadClass road_class = com::nio::map::adas::flat::RoadClass_R_NONE,
    ::flatbuffers::Offset<::flatbuffers::String> road_name = 0,
    bool is_overhead = false,
    bool has_parallel = false,
    bool has_multiout = false,
    bool has_mixfork = false,
    int32_t formway = 0,
    int32_t link_direct = 0,
    int32_t origin_road_class = 0,
    bool is_toll = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> origin_formway = 0,
    int32_t lane_num = 0,
    int32_t speed_limit = 0,
    int32_t history_speed = 0,
    int32_t travelTime = 0)
{
    SDLinkInfoBuilder builder_(_fbb);
    builder_.add_data_version(data_version);
    builder_.add_linkid(linkid);
    builder_.add_travelTime(travelTime);
    builder_.add_history_speed(history_speed);
    builder_.add_speed_limit(speed_limit);
    builder_.add_lane_num(lane_num);
    builder_.add_origin_formway(origin_formway);
    builder_.add_origin_road_class(origin_road_class);
    builder_.add_link_direct(link_direct);
    builder_.add_formway(formway);
    builder_.add_road_name(road_name);
    builder_.add_road_class(road_class);
    builder_.add_link_length(link_length);
    builder_.add_shape_points(shape_points);
    builder_.add_is_toll(is_toll);
    builder_.add_has_mixfork(has_mixfork);
    builder_.add_has_multiout(has_multiout);
    builder_.add_has_parallel(has_parallel);
    builder_.add_is_overhead(is_overhead);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<SDLinkInfo> CreateSDLinkInfoDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    uint64_t linkid = 0,
    uint64_t data_version = 0,
    const std::vector<::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation>>* shape_points = nullptr,
    int32_t link_length = 0,
    com::nio::map::adas::flat::RoadClass road_class = com::nio::map::adas::flat::RoadClass_R_NONE,
    const char* road_name = nullptr,
    bool is_overhead = false,
    bool has_parallel = false,
    bool has_multiout = false,
    bool has_mixfork = false,
    int32_t formway = 0,
    int32_t link_direct = 0,
    int32_t origin_road_class = 0,
    bool is_toll = false,
    const std::vector<int32_t>* origin_formway = nullptr,
    int32_t lane_num = 0,
    int32_t speed_limit = 0,
    int32_t history_speed = 0,
    int32_t travelTime = 0)
{
    auto shape_points__ = shape_points ? _fbb.CreateVector<::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation>>(*shape_points) : 0;
    auto road_name__ = road_name ? _fbb.CreateString(road_name) : 0;
    auto origin_formway__ = origin_formway ? _fbb.CreateVector<int32_t>(*origin_formway) : 0;
    return com::nio::map::adas::flat::CreateSDLinkInfo(
               _fbb,
               linkid,
               data_version,
               shape_points__,
               link_length,
               road_class,
               road_name__,
               is_overhead,
               has_parallel,
               has_multiout,
               has_mixfork,
               formway,
               link_direct,
               origin_road_class,
               is_toll,
               origin_formway__,
               lane_num,
               speed_limit,
               history_speed,
               travelTime);
}

struct SearchByRouteRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef SearchByRouteRequestBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_LINK_LIST = 4
    };
    const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::SDLinkInfo>>* link_list() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::SDLinkInfo>> *>(VT_LINK_LIST);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyOffset(verifier, VT_LINK_LIST) &&
               verifier.VerifyVector(link_list()) &&
               verifier.VerifyVectorOfTables(link_list()) &&
               verifier.EndTable();
    }
};

struct SearchByRouteRequestBuilder
{
    typedef SearchByRouteRequest Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_link_list(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::SDLinkInfo>>> link_list)
    {
        fbb_.AddOffset(SearchByRouteRequest::VT_LINK_LIST, link_list);
    }
    explicit SearchByRouteRequestBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<SearchByRouteRequest> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<SearchByRouteRequest>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<SearchByRouteRequest> CreateSearchByRouteRequest(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::SDLinkInfo>>> link_list = 0)
{
    SearchByRouteRequestBuilder builder_(_fbb);
    builder_.add_link_list(link_list);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<SearchByRouteRequest> CreateSearchByRouteRequestDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<::flatbuffers::Offset<com::nio::map::adas::flat::SDLinkInfo>>* link_list = nullptr)
{
    auto link_list__ = link_list ? _fbb.CreateVector<::flatbuffers::Offset<com::nio::map::adas::flat::SDLinkInfo>>(*link_list) : 0;
    return com::nio::map::adas::flat::CreateSearchByRouteRequest(
               _fbb,
               link_list__);
}

struct FourDEventFilter FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef FourDEventFilterBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_EVENTTYPE = 4,
        VT_PRIORITY = 6
    };
    const ::flatbuffers::String* eventType() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_EVENTTYPE);
    }
    const ::flatbuffers::String* priority() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_PRIORITY);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyOffset(verifier, VT_EVENTTYPE) &&
               verifier.VerifyString(eventType()) &&
               VerifyOffset(verifier, VT_PRIORITY) &&
               verifier.VerifyString(priority()) &&
               verifier.EndTable();
    }
};

struct FourDEventFilterBuilder
{
    typedef FourDEventFilter Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_eventType(::flatbuffers::Offset<::flatbuffers::String> eventType)
    {
        fbb_.AddOffset(FourDEventFilter::VT_EVENTTYPE, eventType);
    }
    void add_priority(::flatbuffers::Offset<::flatbuffers::String> priority)
    {
        fbb_.AddOffset(FourDEventFilter::VT_PRIORITY, priority);
    }
    explicit FourDEventFilterBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<FourDEventFilter> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<FourDEventFilter>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<FourDEventFilter> CreateFourDEventFilter(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    ::flatbuffers::Offset<::flatbuffers::String> eventType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> priority = 0)
{
    FourDEventFilterBuilder builder_(_fbb);
    builder_.add_priority(priority);
    builder_.add_eventType(eventType);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<FourDEventFilter> CreateFourDEventFilterDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    const char* eventType = nullptr,
    const char* priority = nullptr)
{
    auto eventType__ = eventType ? _fbb.CreateString(eventType) : 0;
    auto priority__ = priority ? _fbb.CreateString(priority) : 0;
    return com::nio::map::adas::flat::CreateFourDEventFilter(
               _fbb,
               eventType__,
               priority__);
}

struct FourDCruisePointsRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef FourDCruisePointsRequestBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_REQUEST_DATA_TYPE = 4,
        VT_REQUEST_DATA = 6,
        VT_FILTERS = 8,
        VT_TIMESTAMP = 10
    };
    com::nio::map::adas::flat::FourDCruisePointsData request_data_type() const
    {
        return static_cast<com::nio::map::adas::flat::FourDCruisePointsData>(GetField<uint8_t>(VT_REQUEST_DATA_TYPE, 0));
    }
    const void* request_data() const
    {
        return GetPointer<const void*>(VT_REQUEST_DATA);
    }
    template<typename T> const T* request_data_as() const;
    const com::nio::map::adas::flat::SearchByRoadNameRequest* request_data_as_road_name_request() const
    {
        return request_data_type() == com::nio::map::adas::flat::FourDCruisePointsData_road_name_request ? static_cast<const com::nio::map::adas::flat::SearchByRoadNameRequest*>(request_data()) : nullptr;
    }
    const com::nio::map::adas::flat::SearchByRouteRequest* request_data_as_route_request() const
    {
        return request_data_type() == com::nio::map::adas::flat::FourDCruisePointsData_route_request ? static_cast<const com::nio::map::adas::flat::SearchByRouteRequest*>(request_data()) : nullptr;
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::FourDEventFilter>>* filters() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::FourDEventFilter>> *>(VT_FILTERS);
    }
    uint64_t timestamp() const
    {
        return GetField<uint64_t>(VT_TIMESTAMP, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<uint8_t>(verifier, VT_REQUEST_DATA_TYPE, 1) &&
               VerifyOffset(verifier, VT_REQUEST_DATA) &&
               VerifyFourDCruisePointsData(verifier, request_data(), request_data_type()) &&
               VerifyOffset(verifier, VT_FILTERS) &&
               verifier.VerifyVector(filters()) &&
               verifier.VerifyVectorOfTables(filters()) &&
               VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
               verifier.EndTable();
    }
};

template<> inline const com::nio::map::adas::flat::SearchByRoadNameRequest* FourDCruisePointsRequest::request_data_as<com::nio::map::adas::flat::SearchByRoadNameRequest>() const
{
    return request_data_as_road_name_request();
}

template<> inline const com::nio::map::adas::flat::SearchByRouteRequest* FourDCruisePointsRequest::request_data_as<com::nio::map::adas::flat::SearchByRouteRequest>() const
{
    return request_data_as_route_request();
}

struct FourDCruisePointsRequestBuilder
{
    typedef FourDCruisePointsRequest Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_request_data_type(com::nio::map::adas::flat::FourDCruisePointsData request_data_type)
    {
        fbb_.AddElement<uint8_t>(FourDCruisePointsRequest::VT_REQUEST_DATA_TYPE, static_cast<uint8_t>(request_data_type), 0);
    }
    void add_request_data(::flatbuffers::Offset<void> request_data)
    {
        fbb_.AddOffset(FourDCruisePointsRequest::VT_REQUEST_DATA, request_data);
    }
    void add_filters(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::FourDEventFilter>>> filters)
    {
        fbb_.AddOffset(FourDCruisePointsRequest::VT_FILTERS, filters);
    }
    void add_timestamp(uint64_t timestamp)
    {
        fbb_.AddElement<uint64_t>(FourDCruisePointsRequest::VT_TIMESTAMP, timestamp, 0);
    }
    explicit FourDCruisePointsRequestBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<FourDCruisePointsRequest> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<FourDCruisePointsRequest>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<FourDCruisePointsRequest> CreateFourDCruisePointsRequest(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    com::nio::map::adas::flat::FourDCruisePointsData request_data_type = com::nio::map::adas::flat::FourDCruisePointsData_NONE,
    ::flatbuffers::Offset<void> request_data = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::FourDEventFilter>>> filters = 0,
    uint64_t timestamp = 0)
{
    FourDCruisePointsRequestBuilder builder_(_fbb);
    builder_.add_timestamp(timestamp);
    builder_.add_filters(filters);
    builder_.add_request_data(request_data);
    builder_.add_request_data_type(request_data_type);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<FourDCruisePointsRequest> CreateFourDCruisePointsRequestDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    com::nio::map::adas::flat::FourDCruisePointsData request_data_type = com::nio::map::adas::flat::FourDCruisePointsData_NONE,
    ::flatbuffers::Offset<void> request_data = 0,
    const std::vector<::flatbuffers::Offset<com::nio::map::adas::flat::FourDEventFilter>>* filters = nullptr,
    uint64_t timestamp = 0)
{
    auto filters__ = filters ? _fbb.CreateVector<::flatbuffers::Offset<com::nio::map::adas::flat::FourDEventFilter>>(*filters) : 0;
    return com::nio::map::adas::flat::CreateFourDCruisePointsRequest(
               _fbb,
               request_data_type,
               request_data,
               filters__,
               timestamp);
}

struct SDHDMatchList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef SDHDMatchListBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_SD_LINK_INDEX = 4,
        VT_SD_LINK_ID = 6,
        VT_SD_LINK_OFFSET = 8,
        VT_SD_POINT = 10,
        VT_HD_POINT = 12,
        VT_SD_LINK_OFFSET_TO_ROUTE_START = 14,
        VT_POINT_TYPE = 16
    };
    uint64_t sd_link_index() const
    {
        return GetField<uint64_t>(VT_SD_LINK_INDEX, 0);
    }
    uint64_t sd_link_id() const
    {
        return GetField<uint64_t>(VT_SD_LINK_ID, 0);
    }
    int32_t sd_link_offset() const
    {
        return GetField<int32_t>(VT_SD_LINK_OFFSET, 0);
    }
    const com::nio::map::adas::flat::GPSLocation* sd_point() const
    {
        return GetPointer<const com::nio::map::adas::flat::GPSLocation*>(VT_SD_POINT);
    }
    const com::nio::map::adas::flat::GPSLocation* hd_point() const
    {
        return GetPointer<const com::nio::map::adas::flat::GPSLocation*>(VT_HD_POINT);
    }
    int32_t sd_link_offset_to_route_start() const
    {
        return GetField<int32_t>(VT_SD_LINK_OFFSET_TO_ROUTE_START, 0);
    }
    int32_t point_type() const
    {
        return GetField<int32_t>(VT_POINT_TYPE, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<uint64_t>(verifier, VT_SD_LINK_INDEX, 8) &&
               VerifyField<uint64_t>(verifier, VT_SD_LINK_ID, 8) &&
               VerifyField<int32_t>(verifier, VT_SD_LINK_OFFSET, 4) &&
               VerifyOffset(verifier, VT_SD_POINT) &&
               verifier.VerifyTable(sd_point()) &&
               VerifyOffset(verifier, VT_HD_POINT) &&
               verifier.VerifyTable(hd_point()) &&
               VerifyField<int32_t>(verifier, VT_SD_LINK_OFFSET_TO_ROUTE_START, 4) &&
               VerifyField<int32_t>(verifier, VT_POINT_TYPE, 4) &&
               verifier.EndTable();
    }
};

struct SDHDMatchListBuilder
{
    typedef SDHDMatchList Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_sd_link_index(uint64_t sd_link_index)
    {
        fbb_.AddElement<uint64_t>(SDHDMatchList::VT_SD_LINK_INDEX, sd_link_index, 0);
    }
    void add_sd_link_id(uint64_t sd_link_id)
    {
        fbb_.AddElement<uint64_t>(SDHDMatchList::VT_SD_LINK_ID, sd_link_id, 0);
    }
    void add_sd_link_offset(int32_t sd_link_offset)
    {
        fbb_.AddElement<int32_t>(SDHDMatchList::VT_SD_LINK_OFFSET, sd_link_offset, 0);
    }
    void add_sd_point(::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation> sd_point)
    {
        fbb_.AddOffset(SDHDMatchList::VT_SD_POINT, sd_point);
    }
    void add_hd_point(::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation> hd_point)
    {
        fbb_.AddOffset(SDHDMatchList::VT_HD_POINT, hd_point);
    }
    void add_sd_link_offset_to_route_start(int32_t sd_link_offset_to_route_start)
    {
        fbb_.AddElement<int32_t>(SDHDMatchList::VT_SD_LINK_OFFSET_TO_ROUTE_START, sd_link_offset_to_route_start, 0);
    }
    void add_point_type(int32_t point_type)
    {
        fbb_.AddElement<int32_t>(SDHDMatchList::VT_POINT_TYPE, point_type, 0);
    }
    explicit SDHDMatchListBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<SDHDMatchList> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<SDHDMatchList>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<SDHDMatchList> CreateSDHDMatchList(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    uint64_t sd_link_index = 0,
    uint64_t sd_link_id = 0,
    int32_t sd_link_offset = 0,
    ::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation> sd_point = 0,
    ::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation> hd_point = 0,
    int32_t sd_link_offset_to_route_start = 0,
    int32_t point_type = 0)
{
    SDHDMatchListBuilder builder_(_fbb);
    builder_.add_sd_link_id(sd_link_id);
    builder_.add_sd_link_index(sd_link_index);
    builder_.add_point_type(point_type);
    builder_.add_sd_link_offset_to_route_start(sd_link_offset_to_route_start);
    builder_.add_hd_point(hd_point);
    builder_.add_sd_point(sd_point);
    builder_.add_sd_link_offset(sd_link_offset);
    return builder_.Finish();
}

struct RouteMatchResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef RouteMatchResponseBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_REQUEST_ID = 4,
        VT_RESPONSE_STATE = 6,
        VT_MATCH_LIST = 8,
        VT_SD_TOTAL_LENGTH = 10,
        VT_NAD_COVERED_LENGTH = 12,
        VT_NAD_COVERED_RATIO = 14
    };
    const ::flatbuffers::String* request_id() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_REQUEST_ID);
    }
    int32_t response_state() const
    {
        return GetField<int32_t>(VT_RESPONSE_STATE, 0);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::SDHDMatchList>>* match_list() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::SDHDMatchList>> *>(VT_MATCH_LIST);
    }
    int32_t sd_total_length() const
    {
        return GetField<int32_t>(VT_SD_TOTAL_LENGTH, 0);
    }
    int32_t nad_covered_length() const
    {
        return GetField<int32_t>(VT_NAD_COVERED_LENGTH, 0);
    }
    float nad_covered_ratio() const
    {
        return GetField<float>(VT_NAD_COVERED_RATIO, 0.0f);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyOffset(verifier, VT_REQUEST_ID) &&
               verifier.VerifyString(request_id()) &&
               VerifyField<int32_t>(verifier, VT_RESPONSE_STATE, 4) &&
               VerifyOffset(verifier, VT_MATCH_LIST) &&
               verifier.VerifyVector(match_list()) &&
               verifier.VerifyVectorOfTables(match_list()) &&
               VerifyField<int32_t>(verifier, VT_SD_TOTAL_LENGTH, 4) &&
               VerifyField<int32_t>(verifier, VT_NAD_COVERED_LENGTH, 4) &&
               VerifyField<float>(verifier, VT_NAD_COVERED_RATIO, 4) &&
               verifier.EndTable();
    }
};

struct RouteMatchResponseBuilder
{
    typedef RouteMatchResponse Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_request_id(::flatbuffers::Offset<::flatbuffers::String> request_id)
    {
        fbb_.AddOffset(RouteMatchResponse::VT_REQUEST_ID, request_id);
    }
    void add_response_state(int32_t response_state)
    {
        fbb_.AddElement<int32_t>(RouteMatchResponse::VT_RESPONSE_STATE, response_state, 0);
    }
    void add_match_list(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::SDHDMatchList>>> match_list)
    {
        fbb_.AddOffset(RouteMatchResponse::VT_MATCH_LIST, match_list);
    }
    void add_sd_total_length(int32_t sd_total_length)
    {
        fbb_.AddElement<int32_t>(RouteMatchResponse::VT_SD_TOTAL_LENGTH, sd_total_length, 0);
    }
    void add_nad_covered_length(int32_t nad_covered_length)
    {
        fbb_.AddElement<int32_t>(RouteMatchResponse::VT_NAD_COVERED_LENGTH, nad_covered_length, 0);
    }
    void add_nad_covered_ratio(float nad_covered_ratio)
    {
        fbb_.AddElement<float>(RouteMatchResponse::VT_NAD_COVERED_RATIO, nad_covered_ratio, 0.0f);
    }
    explicit RouteMatchResponseBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<RouteMatchResponse> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<RouteMatchResponse>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<RouteMatchResponse> CreateRouteMatchResponse(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    ::flatbuffers::Offset<::flatbuffers::String> request_id = 0,
    int32_t response_state = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::SDHDMatchList>>> match_list = 0,
    int32_t sd_total_length = 0,
    int32_t nad_covered_length = 0,
    float nad_covered_ratio = 0.0f)
{
    RouteMatchResponseBuilder builder_(_fbb);
    builder_.add_nad_covered_ratio(nad_covered_ratio);
    builder_.add_nad_covered_length(nad_covered_length);
    builder_.add_sd_total_length(sd_total_length);
    builder_.add_match_list(match_list);
    builder_.add_response_state(response_state);
    builder_.add_request_id(request_id);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<RouteMatchResponse> CreateRouteMatchResponseDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    const char* request_id = nullptr,
    int32_t response_state = 0,
    const std::vector<::flatbuffers::Offset<com::nio::map::adas::flat::SDHDMatchList>>* match_list = nullptr,
    int32_t sd_total_length = 0,
    int32_t nad_covered_length = 0,
    float nad_covered_ratio = 0.0f)
{
    auto request_id__ = request_id ? _fbb.CreateString(request_id) : 0;
    auto match_list__ = match_list ? _fbb.CreateVector<::flatbuffers::Offset<com::nio::map::adas::flat::SDHDMatchList>>(*match_list) : 0;
    return com::nio::map::adas::flat::CreateRouteMatchResponse(
               _fbb,
               request_id__,
               response_state,
               match_list__,
               sd_total_length,
               nad_covered_length,
               nad_covered_ratio);
}

struct NADInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef NADInfoBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_IN_NAD_AREA = 4,
        VT_NAD_POINT_DISTANCE = 6,
        VT_NAD_POINT_TYPE = 8,
        VT_SD_POINT = 10,
        VT_HD_POINT = 12,
        VT_TIMESTAMP = 14
    };
    bool in_nad_area() const
    {
        return GetField<uint8_t>(VT_IN_NAD_AREA, 0) != 0;
    }
    uint32_t nad_point_distance() const
    {
        return GetField<uint32_t>(VT_NAD_POINT_DISTANCE, 0);
    }
    int32_t nad_point_type() const
    {
        return GetField<int32_t>(VT_NAD_POINT_TYPE, 0);
    }
    const com::nio::map::adas::flat::GPSLocation* sd_point() const
    {
        return GetPointer<const com::nio::map::adas::flat::GPSLocation*>(VT_SD_POINT);
    }
    const com::nio::map::adas::flat::GPSLocation* hd_point() const
    {
        return GetPointer<const com::nio::map::adas::flat::GPSLocation*>(VT_HD_POINT);
    }
    uint64_t timestamp() const
    {
        return GetField<uint64_t>(VT_TIMESTAMP, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<uint8_t>(verifier, VT_IN_NAD_AREA, 1) &&
               VerifyField<uint32_t>(verifier, VT_NAD_POINT_DISTANCE, 4) &&
               VerifyField<int32_t>(verifier, VT_NAD_POINT_TYPE, 4) &&
               VerifyOffset(verifier, VT_SD_POINT) &&
               verifier.VerifyTable(sd_point()) &&
               VerifyOffset(verifier, VT_HD_POINT) &&
               verifier.VerifyTable(hd_point()) &&
               VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
               verifier.EndTable();
    }
};

struct NADInfoBuilder
{
    typedef NADInfo Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_in_nad_area(bool in_nad_area)
    {
        fbb_.AddElement<uint8_t>(NADInfo::VT_IN_NAD_AREA, static_cast<uint8_t>(in_nad_area), 0);
    }
    void add_nad_point_distance(uint32_t nad_point_distance)
    {
        fbb_.AddElement<uint32_t>(NADInfo::VT_NAD_POINT_DISTANCE, nad_point_distance, 0);
    }
    void add_nad_point_type(int32_t nad_point_type)
    {
        fbb_.AddElement<int32_t>(NADInfo::VT_NAD_POINT_TYPE, nad_point_type, 0);
    }
    void add_sd_point(::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation> sd_point)
    {
        fbb_.AddOffset(NADInfo::VT_SD_POINT, sd_point);
    }
    void add_hd_point(::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation> hd_point)
    {
        fbb_.AddOffset(NADInfo::VT_HD_POINT, hd_point);
    }
    void add_timestamp(uint64_t timestamp)
    {
        fbb_.AddElement<uint64_t>(NADInfo::VT_TIMESTAMP, timestamp, 0);
    }
    explicit NADInfoBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<NADInfo> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<NADInfo>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<NADInfo> CreateNADInfo(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    bool in_nad_area = false,
    uint32_t nad_point_distance = 0,
    int32_t nad_point_type = 0,
    ::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation> sd_point = 0,
    ::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation> hd_point = 0,
    uint64_t timestamp = 0)
{
    NADInfoBuilder builder_(_fbb);
    builder_.add_timestamp(timestamp);
    builder_.add_hd_point(hd_point);
    builder_.add_sd_point(sd_point);
    builder_.add_nad_point_type(nad_point_type);
    builder_.add_nad_point_distance(nad_point_distance);
    builder_.add_in_nad_area(in_nad_area);
    return builder_.Finish();
}

struct RoadCondition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef RoadConditionBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_ROADCONDITIONTYPE = 4,
        VT_LENGTH = 6,
        VT_TIMEOFSECONDS = 8,
        VT_STARTLINKID = 10
    };
    com::nio::map::adas::flat::RoadConditionType roadConditionType() const
    {
        return static_cast<com::nio::map::adas::flat::RoadConditionType>(GetField<int32_t>(VT_ROADCONDITIONTYPE, 0));
    }
    uint32_t length() const
    {
        return GetField<uint32_t>(VT_LENGTH, 0);
    }
    uint64_t timeOfSeconds() const
    {
        return GetField<uint64_t>(VT_TIMEOFSECONDS, 0);
    }
    uint64_t startLinkId() const
    {
        return GetField<uint64_t>(VT_STARTLINKID, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<int32_t>(verifier, VT_ROADCONDITIONTYPE, 4) &&
               VerifyField<uint32_t>(verifier, VT_LENGTH, 4) &&
               VerifyField<uint64_t>(verifier, VT_TIMEOFSECONDS, 8) &&
               VerifyField<uint64_t>(verifier, VT_STARTLINKID, 8) &&
               verifier.EndTable();
    }
};

struct RoadConditionBuilder
{
    typedef RoadCondition Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_roadConditionType(com::nio::map::adas::flat::RoadConditionType roadConditionType)
    {
        fbb_.AddElement<int32_t>(RoadCondition::VT_ROADCONDITIONTYPE, static_cast<int32_t>(roadConditionType), 0);
    }
    void add_length(uint32_t length)
    {
        fbb_.AddElement<uint32_t>(RoadCondition::VT_LENGTH, length, 0);
    }
    void add_timeOfSeconds(uint64_t timeOfSeconds)
    {
        fbb_.AddElement<uint64_t>(RoadCondition::VT_TIMEOFSECONDS, timeOfSeconds, 0);
    }
    void add_startLinkId(uint64_t startLinkId)
    {
        fbb_.AddElement<uint64_t>(RoadCondition::VT_STARTLINKID, startLinkId, 0);
    }
    explicit RoadConditionBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<RoadCondition> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<RoadCondition>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<RoadCondition> CreateRoadCondition(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    com::nio::map::adas::flat::RoadConditionType roadConditionType = com::nio::map::adas::flat::RoadConditionType_RC_TYPE_INVALID,
    uint32_t length = 0,
    uint64_t timeOfSeconds = 0,
    uint64_t startLinkId = 0)
{
    RoadConditionBuilder builder_(_fbb);
    builder_.add_startLinkId(startLinkId);
    builder_.add_timeOfSeconds(timeOfSeconds);
    builder_.add_length(length);
    builder_.add_roadConditionType(roadConditionType);
    return builder_.Finish();
}

struct RoadConditionInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef RoadConditionInfoBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_ROADCONDITIONLIST = 4,
        VT_CARPROGRESS = 6,
        VT_TIMESTAMP = 8
    };
    const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::RoadCondition>>* roadConditionList() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::RoadCondition>> *>(VT_ROADCONDITIONLIST);
    }
    float carProgress() const
    {
        return GetField<float>(VT_CARPROGRESS, 0.0f);
    }
    uint64_t timestamp() const
    {
        return GetField<uint64_t>(VT_TIMESTAMP, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyOffset(verifier, VT_ROADCONDITIONLIST) &&
               verifier.VerifyVector(roadConditionList()) &&
               verifier.VerifyVectorOfTables(roadConditionList()) &&
               VerifyField<float>(verifier, VT_CARPROGRESS, 4) &&
               VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
               verifier.EndTable();
    }
};

struct RoadConditionInfoBuilder
{
    typedef RoadConditionInfo Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_roadConditionList(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::RoadCondition>>> roadConditionList)
    {
        fbb_.AddOffset(RoadConditionInfo::VT_ROADCONDITIONLIST, roadConditionList);
    }
    void add_carProgress(float carProgress)
    {
        fbb_.AddElement<float>(RoadConditionInfo::VT_CARPROGRESS, carProgress, 0.0f);
    }
    void add_timestamp(uint64_t timestamp)
    {
        fbb_.AddElement<uint64_t>(RoadConditionInfo::VT_TIMESTAMP, timestamp, 0);
    }
    explicit RoadConditionInfoBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<RoadConditionInfo> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<RoadConditionInfo>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<RoadConditionInfo> CreateRoadConditionInfo(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::RoadCondition>>> roadConditionList = 0,
    float carProgress = 0.0f,
    uint64_t timestamp = 0)
{
    RoadConditionInfoBuilder builder_(_fbb);
    builder_.add_timestamp(timestamp);
    builder_.add_carProgress(carProgress);
    builder_.add_roadConditionList(roadConditionList);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<RoadConditionInfo> CreateRoadConditionInfoDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<::flatbuffers::Offset<com::nio::map::adas::flat::RoadCondition>>* roadConditionList = nullptr,
    float carProgress = 0.0f,
    uint64_t timestamp = 0)
{
    auto roadConditionList__ = roadConditionList ? _fbb.CreateVector<::flatbuffers::Offset<com::nio::map::adas::flat::RoadCondition>>(*roadConditionList) : 0;
    return com::nio::map::adas::flat::CreateRoadConditionInfo(
               _fbb,
               roadConditionList__,
               carProgress,
               timestamp);
}

struct ResetPredictiveTree FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef ResetPredictiveTreeBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_RESETPREDICTIVETREE = 4
    };
    bool resetPredictiveTree() const
    {
        return GetField<uint8_t>(VT_RESETPREDICTIVETREE, 0) != 0;
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<uint8_t>(verifier, VT_RESETPREDICTIVETREE, 1) &&
               verifier.EndTable();
    }
};

struct ResetPredictiveTreeBuilder
{
    typedef ResetPredictiveTree Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_resetPredictiveTree(bool resetPredictiveTree)
    {
        fbb_.AddElement<uint8_t>(ResetPredictiveTree::VT_RESETPREDICTIVETREE, static_cast<uint8_t>(resetPredictiveTree), 0);
    }
    explicit ResetPredictiveTreeBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<ResetPredictiveTree> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<ResetPredictiveTree>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<ResetPredictiveTree> CreateResetPredictiveTree(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    bool resetPredictiveTree = false)
{
    ResetPredictiveTreeBuilder builder_(_fbb);
    builder_.add_resetPredictiveTree(resetPredictiveTree);
    return builder_.Finish();
}

struct HDRoutesEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef HDRoutesEventBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_DISTANCEMETER = 4,
        VT_HDROUTESEVENTID = 6,
        VT_HDROUTESEVENTTYPE = 8,
        VT_EXTRAINFO = 10,
        VT_EVENTHDLINKID = 12,
        VT_EVENTHDLANEID = 14,
        VT_EVENTID = 16
    };
    uint64_t distanceMeter() const
    {
        return GetField<uint64_t>(VT_DISTANCEMETER, 0);
    }
    com::nio::map::adas::flat::HdRoutesEventID hdRoutesEventId() const
    {
        return static_cast<com::nio::map::adas::flat::HdRoutesEventID>(GetField<int32_t>(VT_HDROUTESEVENTID, 0));
    }
    com::nio::map::adas::flat::HdRoutesEventType hdRoutesEventType() const
    {
        return static_cast<com::nio::map::adas::flat::HdRoutesEventType>(GetField<int32_t>(VT_HDROUTESEVENTTYPE, 0));
    }
    int32_t extraInfo() const
    {
        return GetField<int32_t>(VT_EXTRAINFO, 0);
    }
    uint64_t eventHdLinkId() const
    {
        return GetField<uint64_t>(VT_EVENTHDLINKID, 0);
    }
    uint64_t eventHdLaneId() const
    {
        return GetField<uint64_t>(VT_EVENTHDLANEID, 0);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>* eventId() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_EVENTID);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<uint64_t>(verifier, VT_DISTANCEMETER, 8) &&
               VerifyField<int32_t>(verifier, VT_HDROUTESEVENTID, 4) &&
               VerifyField<int32_t>(verifier, VT_HDROUTESEVENTTYPE, 4) &&
               VerifyField<int32_t>(verifier, VT_EXTRAINFO, 4) &&
               VerifyField<uint64_t>(verifier, VT_EVENTHDLINKID, 8) &&
               VerifyField<uint64_t>(verifier, VT_EVENTHDLANEID, 8) &&
               VerifyOffset(verifier, VT_EVENTID) &&
               verifier.VerifyVector(eventId()) &&
               verifier.VerifyVectorOfStrings(eventId()) &&
               verifier.EndTable();
    }
};

struct HDRoutesEventBuilder
{
    typedef HDRoutesEvent Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_distanceMeter(uint64_t distanceMeter)
    {
        fbb_.AddElement<uint64_t>(HDRoutesEvent::VT_DISTANCEMETER, distanceMeter, 0);
    }
    void add_hdRoutesEventId(com::nio::map::adas::flat::HdRoutesEventID hdRoutesEventId)
    {
        fbb_.AddElement<int32_t>(HDRoutesEvent::VT_HDROUTESEVENTID, static_cast<int32_t>(hdRoutesEventId), 0);
    }
    void add_hdRoutesEventType(com::nio::map::adas::flat::HdRoutesEventType hdRoutesEventType)
    {
        fbb_.AddElement<int32_t>(HDRoutesEvent::VT_HDROUTESEVENTTYPE, static_cast<int32_t>(hdRoutesEventType), 0);
    }
    void add_extraInfo(int32_t extraInfo)
    {
        fbb_.AddElement<int32_t>(HDRoutesEvent::VT_EXTRAINFO, extraInfo, 0);
    }
    void add_eventHdLinkId(uint64_t eventHdLinkId)
    {
        fbb_.AddElement<uint64_t>(HDRoutesEvent::VT_EVENTHDLINKID, eventHdLinkId, 0);
    }
    void add_eventHdLaneId(uint64_t eventHdLaneId)
    {
        fbb_.AddElement<uint64_t>(HDRoutesEvent::VT_EVENTHDLANEID, eventHdLaneId, 0);
    }
    void add_eventId(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> eventId)
    {
        fbb_.AddOffset(HDRoutesEvent::VT_EVENTID, eventId);
    }
    explicit HDRoutesEventBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<HDRoutesEvent> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<HDRoutesEvent>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<HDRoutesEvent> CreateHDRoutesEvent(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    uint64_t distanceMeter = 0,
    com::nio::map::adas::flat::HdRoutesEventID hdRoutesEventId = com::nio::map::adas::flat::HdRoutesEventID_APPROACHING_SA_EVNET,
    com::nio::map::adas::flat::HdRoutesEventType hdRoutesEventType = com::nio::map::adas::flat::HdRoutesEventType_AO_DEGRADE,
    int32_t extraInfo = 0,
    uint64_t eventHdLinkId = 0,
    uint64_t eventHdLaneId = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> eventId = 0)
{
    HDRoutesEventBuilder builder_(_fbb);
    builder_.add_eventHdLaneId(eventHdLaneId);
    builder_.add_eventHdLinkId(eventHdLinkId);
    builder_.add_distanceMeter(distanceMeter);
    builder_.add_eventId(eventId);
    builder_.add_extraInfo(extraInfo);
    builder_.add_hdRoutesEventType(hdRoutesEventType);
    builder_.add_hdRoutesEventId(hdRoutesEventId);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<HDRoutesEvent> CreateHDRoutesEventDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    uint64_t distanceMeter = 0,
    com::nio::map::adas::flat::HdRoutesEventID hdRoutesEventId = com::nio::map::adas::flat::HdRoutesEventID_APPROACHING_SA_EVNET,
    com::nio::map::adas::flat::HdRoutesEventType hdRoutesEventType = com::nio::map::adas::flat::HdRoutesEventType_AO_DEGRADE,
    int32_t extraInfo = 0,
    uint64_t eventHdLinkId = 0,
    uint64_t eventHdLaneId = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>>* eventId = nullptr)
{
    auto eventId__ = eventId ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*eventId) : 0;
    return com::nio::map::adas::flat::CreateHDRoutesEvent(
               _fbb,
               distanceMeter,
               hdRoutesEventId,
               hdRoutesEventType,
               extraInfo,
               eventHdLinkId,
               eventHdLaneId,
               eventId__);
}

struct DynamicTurnKindInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef DynamicTurnKindInfoBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_TURN_KIND_INFO_IDS = 4,
        VT_LINK_COUNT = 6,
        VT_TURN_INFO_DISTANCE = 8,
        VT_HD_LINK_ID = 10,
        VT_SRC_FLOOR = 12,
        VT_TAR_FLOOR = 14
    };
    const ::flatbuffers::Vector<int32_t>* turn_kind_info_ids() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_TURN_KIND_INFO_IDS);
    }
    int32_t link_count() const
    {
        return GetField<int32_t>(VT_LINK_COUNT, 0);
    }
    float turn_info_distance() const
    {
        return GetField<float>(VT_TURN_INFO_DISTANCE, 0.0f);
    }
    uint64_t hd_link_id() const
    {
        return GetField<uint64_t>(VT_HD_LINK_ID, 0);
    }
    int32_t src_floor() const
    {
        return GetField<int32_t>(VT_SRC_FLOOR, 0);
    }
    int32_t tar_floor() const
    {
        return GetField<int32_t>(VT_TAR_FLOOR, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyOffset(verifier, VT_TURN_KIND_INFO_IDS) &&
               verifier.VerifyVector(turn_kind_info_ids()) &&
               VerifyField<int32_t>(verifier, VT_LINK_COUNT, 4) &&
               VerifyField<float>(verifier, VT_TURN_INFO_DISTANCE, 4) &&
               VerifyField<uint64_t>(verifier, VT_HD_LINK_ID, 8) &&
               VerifyField<int32_t>(verifier, VT_SRC_FLOOR, 4) &&
               VerifyField<int32_t>(verifier, VT_TAR_FLOOR, 4) &&
               verifier.EndTable();
    }
};

struct DynamicTurnKindInfoBuilder
{
    typedef DynamicTurnKindInfo Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_turn_kind_info_ids(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> turn_kind_info_ids)
    {
        fbb_.AddOffset(DynamicTurnKindInfo::VT_TURN_KIND_INFO_IDS, turn_kind_info_ids);
    }
    void add_link_count(int32_t link_count)
    {
        fbb_.AddElement<int32_t>(DynamicTurnKindInfo::VT_LINK_COUNT, link_count, 0);
    }
    void add_turn_info_distance(float turn_info_distance)
    {
        fbb_.AddElement<float>(DynamicTurnKindInfo::VT_TURN_INFO_DISTANCE, turn_info_distance, 0.0f);
    }
    void add_hd_link_id(uint64_t hd_link_id)
    {
        fbb_.AddElement<uint64_t>(DynamicTurnKindInfo::VT_HD_LINK_ID, hd_link_id, 0);
    }
    void add_src_floor(int32_t src_floor)
    {
        fbb_.AddElement<int32_t>(DynamicTurnKindInfo::VT_SRC_FLOOR, src_floor, 0);
    }
    void add_tar_floor(int32_t tar_floor)
    {
        fbb_.AddElement<int32_t>(DynamicTurnKindInfo::VT_TAR_FLOOR, tar_floor, 0);
    }
    explicit DynamicTurnKindInfoBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<DynamicTurnKindInfo> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<DynamicTurnKindInfo>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<DynamicTurnKindInfo> CreateDynamicTurnKindInfo(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> turn_kind_info_ids = 0,
    int32_t link_count = 0,
    float turn_info_distance = 0.0f,
    uint64_t hd_link_id = 0,
    int32_t src_floor = 0,
    int32_t tar_floor = 0)
{
    DynamicTurnKindInfoBuilder builder_(_fbb);
    builder_.add_hd_link_id(hd_link_id);
    builder_.add_tar_floor(tar_floor);
    builder_.add_src_floor(src_floor);
    builder_.add_turn_info_distance(turn_info_distance);
    builder_.add_link_count(link_count);
    builder_.add_turn_kind_info_ids(turn_kind_info_ids);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<DynamicTurnKindInfo> CreateDynamicTurnKindInfoDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<int32_t>* turn_kind_info_ids = nullptr,
    int32_t link_count = 0,
    float turn_info_distance = 0.0f,
    uint64_t hd_link_id = 0,
    int32_t src_floor = 0,
    int32_t tar_floor = 0)
{
    auto turn_kind_info_ids__ = turn_kind_info_ids ? _fbb.CreateVector<int32_t>(*turn_kind_info_ids) : 0;
    return com::nio::map::adas::flat::CreateDynamicTurnKindInfo(
               _fbb,
               turn_kind_info_ids__,
               link_count,
               turn_info_distance,
               hd_link_id,
               src_floor,
               tar_floor);
}

struct HDRoutesEvents FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef HDRoutesEventsBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_HDROUTESEVENTLIST = 4,
        VT_DYNAMICTURNINFOLIST = 6,
        VT_LASTROUTECHANGETIMESTAMP = 8
    };
    const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::HDRoutesEvent>>* hdRoutesEventList() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::HDRoutesEvent>> *>(VT_HDROUTESEVENTLIST);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::DynamicTurnKindInfo>>* dynamicTurnInfoList() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::DynamicTurnKindInfo>> *>(VT_DYNAMICTURNINFOLIST);
    }
    uint64_t lastRouteChangeTimestamp() const
    {
        return GetField<uint64_t>(VT_LASTROUTECHANGETIMESTAMP, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyOffset(verifier, VT_HDROUTESEVENTLIST) &&
               verifier.VerifyVector(hdRoutesEventList()) &&
               verifier.VerifyVectorOfTables(hdRoutesEventList()) &&
               VerifyOffset(verifier, VT_DYNAMICTURNINFOLIST) &&
               verifier.VerifyVector(dynamicTurnInfoList()) &&
               verifier.VerifyVectorOfTables(dynamicTurnInfoList()) &&
               VerifyField<uint64_t>(verifier, VT_LASTROUTECHANGETIMESTAMP, 8) &&
               verifier.EndTable();
    }
};

struct HDRoutesEventsBuilder
{
    typedef HDRoutesEvents Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_hdRoutesEventList(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::HDRoutesEvent>>> hdRoutesEventList)
    {
        fbb_.AddOffset(HDRoutesEvents::VT_HDROUTESEVENTLIST, hdRoutesEventList);
    }
    void add_dynamicTurnInfoList(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::DynamicTurnKindInfo>>> dynamicTurnInfoList)
    {
        fbb_.AddOffset(HDRoutesEvents::VT_DYNAMICTURNINFOLIST, dynamicTurnInfoList);
    }
    void add_lastRouteChangeTimestamp(uint64_t lastRouteChangeTimestamp)
    {
        fbb_.AddElement<uint64_t>(HDRoutesEvents::VT_LASTROUTECHANGETIMESTAMP, lastRouteChangeTimestamp, 0);
    }
    explicit HDRoutesEventsBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<HDRoutesEvents> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<HDRoutesEvents>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<HDRoutesEvents> CreateHDRoutesEvents(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::HDRoutesEvent>>> hdRoutesEventList = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::DynamicTurnKindInfo>>> dynamicTurnInfoList = 0,
    uint64_t lastRouteChangeTimestamp = 0)
{
    HDRoutesEventsBuilder builder_(_fbb);
    builder_.add_lastRouteChangeTimestamp(lastRouteChangeTimestamp);
    builder_.add_dynamicTurnInfoList(dynamicTurnInfoList);
    builder_.add_hdRoutesEventList(hdRoutesEventList);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<HDRoutesEvents> CreateHDRoutesEventsDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<::flatbuffers::Offset<com::nio::map::adas::flat::HDRoutesEvent>>* hdRoutesEventList = nullptr,
    const std::vector<::flatbuffers::Offset<com::nio::map::adas::flat::DynamicTurnKindInfo>>* dynamicTurnInfoList = nullptr,
    uint64_t lastRouteChangeTimestamp = 0)
{
    auto hdRoutesEventList__ = hdRoutesEventList ? _fbb.CreateVector<::flatbuffers::Offset<com::nio::map::adas::flat::HDRoutesEvent>>(*hdRoutesEventList) : 0;
    auto dynamicTurnInfoList__ = dynamicTurnInfoList ? _fbb.CreateVector<::flatbuffers::Offset<com::nio::map::adas::flat::DynamicTurnKindInfo>>(*dynamicTurnInfoList) : 0;
    return com::nio::map::adas::flat::CreateHDRoutesEvents(
               _fbb,
               hdRoutesEventList__,
               dynamicTurnInfoList__,
               lastRouteChangeTimestamp);
}

struct SDMapTable FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef SDMapTableBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_REQUESTID = 4,
        VT_DATA_TYPE = 6,
        VT_DATA = 8,
        VT_ENGINETYPE = 10
    };
    int32_t requestId() const
    {
        return GetField<int32_t>(VT_REQUESTID, 0);
    }
    com::nio::map::adas::flat::SDMapInfo data_type() const
    {
        return static_cast<com::nio::map::adas::flat::SDMapInfo>(GetField<uint8_t>(VT_DATA_TYPE, 0));
    }
    const void* data() const
    {
        return GetPointer<const void*>(VT_DATA);
    }
    template<typename T> const T* data_as() const;
    const com::nio::map::adas::flat::NodeInfoData* data_as_nodeInfo() const
    {
        return data_type() == com::nio::map::adas::flat::SDMapInfo_nodeInfo ? static_cast<const com::nio::map::adas::flat::NodeInfoData*>(data()) : nullptr;
    }
    const com::nio::map::adas::flat::AdasInfoData* data_as_adasInfo() const
    {
        return data_type() == com::nio::map::adas::flat::SDMapInfo_adasInfo ? static_cast<const com::nio::map::adas::flat::AdasInfoData*>(data()) : nullptr;
    }
    const com::nio::map::adas::flat::NopInfoData* data_as_nopInfo() const
    {
        return data_type() == com::nio::map::adas::flat::SDMapInfo_nopInfo ? static_cast<const com::nio::map::adas::flat::NopInfoData*>(data()) : nullptr;
    }
    const com::nio::map::adas::flat::NavMapLocVersion2* data_as_mapLoc() const
    {
        return data_type() == com::nio::map::adas::flat::SDMapInfo_mapLoc ? static_cast<const com::nio::map::adas::flat::NavMapLocVersion2*>(data()) : nullptr;
    }
    const com::nio::map::adas::flat::RouteMatchRequest* data_as_routeMatchRequest() const
    {
        return data_type() == com::nio::map::adas::flat::SDMapInfo_routeMatchRequest ? static_cast<const com::nio::map::adas::flat::RouteMatchRequest*>(data()) : nullptr;
    }
    const com::nio::map::adas::flat::RouteMatchResponse* data_as_routeMatchResponse() const
    {
        return data_type() == com::nio::map::adas::flat::SDMapInfo_routeMatchResponse ? static_cast<const com::nio::map::adas::flat::RouteMatchResponse*>(data()) : nullptr;
    }
    const com::nio::map::adas::flat::NADInfo* data_as_nadInfo() const
    {
        return data_type() == com::nio::map::adas::flat::SDMapInfo_nadInfo ? static_cast<const com::nio::map::adas::flat::NADInfo*>(data()) : nullptr;
    }
    const com::nio::map::adas::flat::RoadConditionInfo* data_as_roadConditionInfo() const
    {
        return data_type() == com::nio::map::adas::flat::SDMapInfo_roadConditionInfo ? static_cast<const com::nio::map::adas::flat::RoadConditionInfo*>(data()) : nullptr;
    }
    const com::nio::map::adas::flat::ResetPredictiveTree* data_as_resetPredictiveTree() const
    {
        return data_type() == com::nio::map::adas::flat::SDMapInfo_resetPredictiveTree ? static_cast<const com::nio::map::adas::flat::ResetPredictiveTree*>(data()) : nullptr;
    }
    const com::nio::map::adas::flat::HDRoutesEvents* data_as_hdRoutesEvents() const
    {
        return data_type() == com::nio::map::adas::flat::SDMapInfo_hdRoutesEvents ? static_cast<const com::nio::map::adas::flat::HDRoutesEvents*>(data()) : nullptr;
    }
    const com::nio::map::adas::flat::BumpyPoisInfo* data_as_bumpyPois() const
    {
        return data_type() == com::nio::map::adas::flat::SDMapInfo_bumpyPois ? static_cast<const com::nio::map::adas::flat::BumpyPoisInfo*>(data()) : nullptr;
    }
    const com::nio::map::adas::flat::TrafficLightCountdownList* data_as_trafficLightCountdown() const
    {
        return data_type() == com::nio::map::adas::flat::SDMapInfo_trafficLightCountdown ? static_cast<const com::nio::map::adas::flat::TrafficLightCountdownList*>(data()) : nullptr;
    }
    const com::nio::map::adas::flat::FourDCruisePointsRequest* data_as_fourDCruisePointsRequest() const
    {
        return data_type() == com::nio::map::adas::flat::SDMapInfo_fourDCruisePointsRequest ? static_cast<const com::nio::map::adas::flat::FourDCruisePointsRequest*>(data()) : nullptr;
    }
    int32_t engineType() const
    {
        return GetField<int32_t>(VT_ENGINETYPE, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<int32_t>(verifier, VT_REQUESTID, 4) &&
               VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
               VerifyOffset(verifier, VT_DATA) &&
               VerifySDMapInfo(verifier, data(), data_type()) &&
               VerifyField<int32_t>(verifier, VT_ENGINETYPE, 4) &&
               verifier.EndTable();
    }
};

template<> inline const com::nio::map::adas::flat::NodeInfoData* SDMapTable::data_as<com::nio::map::adas::flat::NodeInfoData>() const
{
    return data_as_nodeInfo();
}

template<> inline const com::nio::map::adas::flat::AdasInfoData* SDMapTable::data_as<com::nio::map::adas::flat::AdasInfoData>() const
{
    return data_as_adasInfo();
}

template<> inline const com::nio::map::adas::flat::NopInfoData* SDMapTable::data_as<com::nio::map::adas::flat::NopInfoData>() const
{
    return data_as_nopInfo();
}

template<> inline const com::nio::map::adas::flat::NavMapLocVersion2* SDMapTable::data_as<com::nio::map::adas::flat::NavMapLocVersion2>() const
{
    return data_as_mapLoc();
}

template<> inline const com::nio::map::adas::flat::RouteMatchRequest* SDMapTable::data_as<com::nio::map::adas::flat::RouteMatchRequest>() const
{
    return data_as_routeMatchRequest();
}

template<> inline const com::nio::map::adas::flat::RouteMatchResponse* SDMapTable::data_as<com::nio::map::adas::flat::RouteMatchResponse>() const
{
    return data_as_routeMatchResponse();
}

template<> inline const com::nio::map::adas::flat::NADInfo* SDMapTable::data_as<com::nio::map::adas::flat::NADInfo>() const
{
    return data_as_nadInfo();
}

template<> inline const com::nio::map::adas::flat::RoadConditionInfo* SDMapTable::data_as<com::nio::map::adas::flat::RoadConditionInfo>() const
{
    return data_as_roadConditionInfo();
}

template<> inline const com::nio::map::adas::flat::ResetPredictiveTree* SDMapTable::data_as<com::nio::map::adas::flat::ResetPredictiveTree>() const
{
    return data_as_resetPredictiveTree();
}

template<> inline const com::nio::map::adas::flat::HDRoutesEvents* SDMapTable::data_as<com::nio::map::adas::flat::HDRoutesEvents>() const
{
    return data_as_hdRoutesEvents();
}

template<> inline const com::nio::map::adas::flat::BumpyPoisInfo* SDMapTable::data_as<com::nio::map::adas::flat::BumpyPoisInfo>() const
{
    return data_as_bumpyPois();
}

template<> inline const com::nio::map::adas::flat::TrafficLightCountdownList* SDMapTable::data_as<com::nio::map::adas::flat::TrafficLightCountdownList>() const
{
    return data_as_trafficLightCountdown();
}

template<> inline const com::nio::map::adas::flat::FourDCruisePointsRequest* SDMapTable::data_as<com::nio::map::adas::flat::FourDCruisePointsRequest>() const
{
    return data_as_fourDCruisePointsRequest();
}

struct SDMapTableBuilder
{
    typedef SDMapTable Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_requestId(int32_t requestId)
    {
        fbb_.AddElement<int32_t>(SDMapTable::VT_REQUESTID, requestId, 0);
    }
    void add_data_type(com::nio::map::adas::flat::SDMapInfo data_type)
    {
        fbb_.AddElement<uint8_t>(SDMapTable::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
    }
    void add_data(::flatbuffers::Offset<void> data)
    {
        fbb_.AddOffset(SDMapTable::VT_DATA, data);
    }
    void add_engineType(int32_t engineType)
    {
        fbb_.AddElement<int32_t>(SDMapTable::VT_ENGINETYPE, engineType, 0);
    }
    explicit SDMapTableBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<SDMapTable> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<SDMapTable>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<SDMapTable> CreateSDMapTable(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    int32_t requestId = 0,
    com::nio::map::adas::flat::SDMapInfo data_type = com::nio::map::adas::flat::SDMapInfo_NONE,
    ::flatbuffers::Offset<void> data = 0,
    int32_t engineType = 0)
{
    SDMapTableBuilder builder_(_fbb);
    builder_.add_engineType(engineType);
    builder_.add_data(data);
    builder_.add_requestId(requestId);
    builder_.add_data_type(data_type);
    return builder_.Finish();
}

struct LaneInfoList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef LaneInfoListBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_LANEINFO = 4
    };
    const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::LaneInfo>>* laneInfo() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::LaneInfo>> *>(VT_LANEINFO);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyOffset(verifier, VT_LANEINFO) &&
               verifier.VerifyVector(laneInfo()) &&
               verifier.VerifyVectorOfTables(laneInfo()) &&
               verifier.EndTable();
    }
};

struct LaneInfoListBuilder
{
    typedef LaneInfoList Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_laneInfo(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::LaneInfo>>> laneInfo)
    {
        fbb_.AddOffset(LaneInfoList::VT_LANEINFO, laneInfo);
    }
    explicit LaneInfoListBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<LaneInfoList> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<LaneInfoList>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<LaneInfoList> CreateLaneInfoList(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::LaneInfo>>> laneInfo = 0)
{
    LaneInfoListBuilder builder_(_fbb);
    builder_.add_laneInfo(laneInfo);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<LaneInfoList> CreateLaneInfoListDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<::flatbuffers::Offset<com::nio::map::adas::flat::LaneInfo>>* laneInfo = nullptr)
{
    auto laneInfo__ = laneInfo ? _fbb.CreateVector<::flatbuffers::Offset<com::nio::map::adas::flat::LaneInfo>>(*laneInfo) : 0;
    return com::nio::map::adas::flat::CreateLaneInfoList(
               _fbb,
               laneInfo__);
}

struct BumpyPoisInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef BumpyPoisInfoBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_BUMPYPOIS = 4
    };
    const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoi>>* bumpyPois() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoi>> *>(VT_BUMPYPOIS);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyOffset(verifier, VT_BUMPYPOIS) &&
               verifier.VerifyVector(bumpyPois()) &&
               verifier.VerifyVectorOfTables(bumpyPois()) &&
               verifier.EndTable();
    }
};

struct BumpyPoisInfoBuilder
{
    typedef BumpyPoisInfo Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_bumpyPois(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoi>>> bumpyPois)
    {
        fbb_.AddOffset(BumpyPoisInfo::VT_BUMPYPOIS, bumpyPois);
    }
    explicit BumpyPoisInfoBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<BumpyPoisInfo> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<BumpyPoisInfo>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<BumpyPoisInfo> CreateBumpyPoisInfo(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoi>>> bumpyPois = 0)
{
    BumpyPoisInfoBuilder builder_(_fbb);
    builder_.add_bumpyPois(bumpyPois);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<BumpyPoisInfo> CreateBumpyPoisInfoDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoi>>* bumpyPois = nullptr)
{
    auto bumpyPois__ = bumpyPois ? _fbb.CreateVector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoi>>(*bumpyPois) : 0;
    return com::nio::map::adas::flat::CreateBumpyPoisInfo(
               _fbb,
               bumpyPois__);
}

struct BumpyPoi FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef BumpyPoiBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_ID = 4,
        VT_TYPE = 6,
        VT_SUBTYPE = 8,
        VT_REMAINDISTANCE = 10,
        VT_ATTRIBUTES = 12,
        VT_POINTS = 14,
        VT_EXTRAATTRIBUTES = 16
    };
    const ::flatbuffers::String* id() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_ID);
    }
    int32_t type() const
    {
        return GetField<int32_t>(VT_TYPE, 0);
    }
    int32_t subType() const
    {
        return GetField<int32_t>(VT_SUBTYPE, 0);
    }
    int32_t remainDistance() const
    {
        return GetField<int32_t>(VT_REMAINDISTANCE, 0);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoiAttribute>>* attributes() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoiAttribute>> *>(VT_ATTRIBUTES);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoiPoints>>* points() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoiPoints>> *>(VT_POINTS);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoiExtaAttribute>>* extraAttributes() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoiExtaAttribute>> *>(VT_EXTRAATTRIBUTES);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyOffset(verifier, VT_ID) &&
               verifier.VerifyString(id()) &&
               VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
               VerifyField<int32_t>(verifier, VT_SUBTYPE, 4) &&
               VerifyField<int32_t>(verifier, VT_REMAINDISTANCE, 4) &&
               VerifyOffset(verifier, VT_ATTRIBUTES) &&
               verifier.VerifyVector(attributes()) &&
               verifier.VerifyVectorOfTables(attributes()) &&
               VerifyOffset(verifier, VT_POINTS) &&
               verifier.VerifyVector(points()) &&
               verifier.VerifyVectorOfTables(points()) &&
               VerifyOffset(verifier, VT_EXTRAATTRIBUTES) &&
               verifier.VerifyVector(extraAttributes()) &&
               verifier.VerifyVectorOfTables(extraAttributes()) &&
               verifier.EndTable();
    }
};

struct BumpyPoiBuilder
{
    typedef BumpyPoi Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_id(::flatbuffers::Offset<::flatbuffers::String> id)
    {
        fbb_.AddOffset(BumpyPoi::VT_ID, id);
    }
    void add_type(int32_t type)
    {
        fbb_.AddElement<int32_t>(BumpyPoi::VT_TYPE, type, 0);
    }
    void add_subType(int32_t subType)
    {
        fbb_.AddElement<int32_t>(BumpyPoi::VT_SUBTYPE, subType, 0);
    }
    void add_remainDistance(int32_t remainDistance)
    {
        fbb_.AddElement<int32_t>(BumpyPoi::VT_REMAINDISTANCE, remainDistance, 0);
    }
    void add_attributes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoiAttribute>>> attributes)
    {
        fbb_.AddOffset(BumpyPoi::VT_ATTRIBUTES, attributes);
    }
    void add_points(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoiPoints>>> points)
    {
        fbb_.AddOffset(BumpyPoi::VT_POINTS, points);
    }
    void add_extraAttributes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoiExtaAttribute>>> extraAttributes)
    {
        fbb_.AddOffset(BumpyPoi::VT_EXTRAATTRIBUTES, extraAttributes);
    }
    explicit BumpyPoiBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<BumpyPoi> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<BumpyPoi>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<BumpyPoi> CreateBumpyPoi(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    int32_t type = 0,
    int32_t subType = 0,
    int32_t remainDistance = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoiAttribute>>> attributes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoiPoints>>> points = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoiExtaAttribute>>> extraAttributes = 0)
{
    BumpyPoiBuilder builder_(_fbb);
    builder_.add_extraAttributes(extraAttributes);
    builder_.add_points(points);
    builder_.add_attributes(attributes);
    builder_.add_remainDistance(remainDistance);
    builder_.add_subType(subType);
    builder_.add_type(type);
    builder_.add_id(id);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<BumpyPoi> CreateBumpyPoiDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    const char* id = nullptr,
    int32_t type = 0,
    int32_t subType = 0,
    int32_t remainDistance = 0,
    const std::vector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoiAttribute>>* attributes = nullptr,
    const std::vector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoiPoints>>* points = nullptr,
    const std::vector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoiExtaAttribute>>* extraAttributes = nullptr)
{
    auto id__ = id ? _fbb.CreateString(id) : 0;
    auto attributes__ = attributes ? _fbb.CreateVector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoiAttribute>>(*attributes) : 0;
    auto points__ = points ? _fbb.CreateVector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoiPoints>>(*points) : 0;
    auto extraAttributes__ = extraAttributes ? _fbb.CreateVector<::flatbuffers::Offset<com::nio::map::adas::flat::BumpyPoiExtaAttribute>>(*extraAttributes) : 0;
    return com::nio::map::adas::flat::CreateBumpyPoi(
               _fbb,
               id__,
               type,
               subType,
               remainDistance,
               attributes__,
               points__,
               extraAttributes__);
}

struct BumpyPoiAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef BumpyPoiAttributeBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_TYPE = 4,
        VT_VALUE = 6
    };
    int32_t type() const
    {
        return GetField<int32_t>(VT_TYPE, 0);
    }
    float value() const
    {
        return GetField<float>(VT_VALUE, 0.0f);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
               VerifyField<float>(verifier, VT_VALUE, 4) &&
               verifier.EndTable();
    }
};

struct BumpyPoiAttributeBuilder
{
    typedef BumpyPoiAttribute Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_type(int32_t type)
    {
        fbb_.AddElement<int32_t>(BumpyPoiAttribute::VT_TYPE, type, 0);
    }
    void add_value(float value)
    {
        fbb_.AddElement<float>(BumpyPoiAttribute::VT_VALUE, value, 0.0f);
    }
    explicit BumpyPoiAttributeBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<BumpyPoiAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<BumpyPoiAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<BumpyPoiAttribute> CreateBumpyPoiAttribute(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    int32_t type = 0,
    float value = 0.0f)
{
    BumpyPoiAttributeBuilder builder_(_fbb);
    builder_.add_value(value);
    builder_.add_type(type);
    return builder_.Finish();
}

struct BumpyPoiExtaAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef BumpyPoiExtaAttributeBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_TYPE = 4,
        VT_VALUE = 6
    };
    const ::flatbuffers::String* type() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_TYPE);
    }
    float value() const
    {
        return GetField<float>(VT_VALUE, 0.0f);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyOffset(verifier, VT_TYPE) &&
               verifier.VerifyString(type()) &&
               VerifyField<float>(verifier, VT_VALUE, 4) &&
               verifier.EndTable();
    }
};

struct BumpyPoiExtaAttributeBuilder
{
    typedef BumpyPoiExtaAttribute Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_type(::flatbuffers::Offset<::flatbuffers::String> type)
    {
        fbb_.AddOffset(BumpyPoiExtaAttribute::VT_TYPE, type);
    }
    void add_value(float value)
    {
        fbb_.AddElement<float>(BumpyPoiExtaAttribute::VT_VALUE, value, 0.0f);
    }
    explicit BumpyPoiExtaAttributeBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<BumpyPoiExtaAttribute> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<BumpyPoiExtaAttribute>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<BumpyPoiExtaAttribute> CreateBumpyPoiExtaAttribute(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    float value = 0.0f)
{
    BumpyPoiExtaAttributeBuilder builder_(_fbb);
    builder_.add_value(value);
    builder_.add_type(type);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<BumpyPoiExtaAttribute> CreateBumpyPoiExtaAttributeDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    const char* type = nullptr,
    float value = 0.0f)
{
    auto type__ = type ? _fbb.CreateString(type) : 0;
    return com::nio::map::adas::flat::CreateBumpyPoiExtaAttribute(
               _fbb,
               type__,
               value);
}

struct BumpyPoiPoints FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef BumpyPoiPointsBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_MMLATITUDE = 4,
        VT_MMLONGITUDE = 6,
        VT_MMHEADING = 8,
        VT_PVATLATITUDE = 10,
        VT_PVATLONGITUDE = 12,
        VT_PVATHEADING = 14
    };
    double mmlatitude() const
    {
        return GetField<double>(VT_MMLATITUDE, 0.0);
    }
    double mmlongitude() const
    {
        return GetField<double>(VT_MMLONGITUDE, 0.0);
    }
    double mmHeading() const
    {
        return GetField<double>(VT_MMHEADING, 0.0);
    }
    double pvatlatitude() const
    {
        return GetField<double>(VT_PVATLATITUDE, 0.0);
    }
    double pvatlongitude() const
    {
        return GetField<double>(VT_PVATLONGITUDE, 0.0);
    }
    double pvatHeading() const
    {
        return GetField<double>(VT_PVATHEADING, 0.0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<double>(verifier, VT_MMLATITUDE, 8) &&
               VerifyField<double>(verifier, VT_MMLONGITUDE, 8) &&
               VerifyField<double>(verifier, VT_MMHEADING, 8) &&
               VerifyField<double>(verifier, VT_PVATLATITUDE, 8) &&
               VerifyField<double>(verifier, VT_PVATLONGITUDE, 8) &&
               VerifyField<double>(verifier, VT_PVATHEADING, 8) &&
               verifier.EndTable();
    }
};

struct BumpyPoiPointsBuilder
{
    typedef BumpyPoiPoints Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_mmlatitude(double mmlatitude)
    {
        fbb_.AddElement<double>(BumpyPoiPoints::VT_MMLATITUDE, mmlatitude, 0.0);
    }
    void add_mmlongitude(double mmlongitude)
    {
        fbb_.AddElement<double>(BumpyPoiPoints::VT_MMLONGITUDE, mmlongitude, 0.0);
    }
    void add_mmHeading(double mmHeading)
    {
        fbb_.AddElement<double>(BumpyPoiPoints::VT_MMHEADING, mmHeading, 0.0);
    }
    void add_pvatlatitude(double pvatlatitude)
    {
        fbb_.AddElement<double>(BumpyPoiPoints::VT_PVATLATITUDE, pvatlatitude, 0.0);
    }
    void add_pvatlongitude(double pvatlongitude)
    {
        fbb_.AddElement<double>(BumpyPoiPoints::VT_PVATLONGITUDE, pvatlongitude, 0.0);
    }
    void add_pvatHeading(double pvatHeading)
    {
        fbb_.AddElement<double>(BumpyPoiPoints::VT_PVATHEADING, pvatHeading, 0.0);
    }
    explicit BumpyPoiPointsBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<BumpyPoiPoints> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<BumpyPoiPoints>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<BumpyPoiPoints> CreateBumpyPoiPoints(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    double mmlatitude = 0.0,
    double mmlongitude = 0.0,
    double mmHeading = 0.0,
    double pvatlatitude = 0.0,
    double pvatlongitude = 0.0,
    double pvatHeading = 0.0)
{
    BumpyPoiPointsBuilder builder_(_fbb);
    builder_.add_pvatHeading(pvatHeading);
    builder_.add_pvatlongitude(pvatlongitude);
    builder_.add_pvatlatitude(pvatlatitude);
    builder_.add_mmHeading(mmHeading);
    builder_.add_mmlongitude(mmlongitude);
    builder_.add_mmlatitude(mmlatitude);
    return builder_.Finish();
}

struct LightState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef LightStateBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_TYPE = 4,
        VT_STIME = 6,
        VT_ETIME = 8
    };
    int32_t type() const
    {
        return GetField<int32_t>(VT_TYPE, 0);
    }
    int64_t stime() const
    {
        return GetField<int64_t>(VT_STIME, 0);
    }
    int64_t etime() const
    {
        return GetField<int64_t>(VT_ETIME, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
               VerifyField<int64_t>(verifier, VT_STIME, 8) &&
               VerifyField<int64_t>(verifier, VT_ETIME, 8) &&
               verifier.EndTable();
    }
};

struct LightStateBuilder
{
    typedef LightState Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_type(int32_t type)
    {
        fbb_.AddElement<int32_t>(LightState::VT_TYPE, type, 0);
    }
    void add_stime(int64_t stime)
    {
        fbb_.AddElement<int64_t>(LightState::VT_STIME, stime, 0);
    }
    void add_etime(int64_t etime)
    {
        fbb_.AddElement<int64_t>(LightState::VT_ETIME, etime, 0);
    }
    explicit LightStateBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<LightState> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<LightState>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<LightState> CreateLightState(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    int32_t type = 0,
    int64_t stime = 0,
    int64_t etime = 0)
{
    LightStateBuilder builder_(_fbb);
    builder_.add_etime(etime);
    builder_.add_stime(stime);
    builder_.add_type(type);
    return builder_.Finish();
}

struct LightInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef LightInfoBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_WAITNUM = 4,
        VT_DIR = 6,
        VT_LIGHTSTATES = 8,
        VT_DESC = 10
    };
    int64_t waitNum() const
    {
        return GetField<int64_t>(VT_WAITNUM, 0);
    }
    int32_t dir() const
    {
        return GetField<int32_t>(VT_DIR, 0);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::LightState>>* lightStates() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::LightState>> *>(VT_LIGHTSTATES);
    }
    const ::flatbuffers::String* desc() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_DESC);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<int64_t>(verifier, VT_WAITNUM, 8) &&
               VerifyField<int32_t>(verifier, VT_DIR, 4) &&
               VerifyOffset(verifier, VT_LIGHTSTATES) &&
               verifier.VerifyVector(lightStates()) &&
               verifier.VerifyVectorOfTables(lightStates()) &&
               VerifyOffset(verifier, VT_DESC) &&
               verifier.VerifyString(desc()) &&
               verifier.EndTable();
    }
};

struct LightInfoBuilder
{
    typedef LightInfo Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_waitNum(int64_t waitNum)
    {
        fbb_.AddElement<int64_t>(LightInfo::VT_WAITNUM, waitNum, 0);
    }
    void add_dir(int32_t dir)
    {
        fbb_.AddElement<int32_t>(LightInfo::VT_DIR, dir, 0);
    }
    void add_lightStates(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::LightState>>> lightStates)
    {
        fbb_.AddOffset(LightInfo::VT_LIGHTSTATES, lightStates);
    }
    void add_desc(::flatbuffers::Offset<::flatbuffers::String> desc)
    {
        fbb_.AddOffset(LightInfo::VT_DESC, desc);
    }
    explicit LightInfoBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<LightInfo> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<LightInfo>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<LightInfo> CreateLightInfo(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    int64_t waitNum = 0,
    int32_t dir = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::LightState>>> lightStates = 0,
    ::flatbuffers::Offset<::flatbuffers::String> desc = 0)
{
    LightInfoBuilder builder_(_fbb);
    builder_.add_waitNum(waitNum);
    builder_.add_desc(desc);
    builder_.add_lightStates(lightStates);
    builder_.add_dir(dir);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<LightInfo> CreateLightInfoDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    int64_t waitNum = 0,
    int32_t dir = 0,
    const std::vector<::flatbuffers::Offset<com::nio::map::adas::flat::LightState>>* lightStates = nullptr,
    const char* desc = nullptr)
{
    auto lightStates__ = lightStates ? _fbb.CreateVector<::flatbuffers::Offset<com::nio::map::adas::flat::LightState>>(*lightStates) : 0;
    auto desc__ = desc ? _fbb.CreateString(desc) : 0;
    return com::nio::map::adas::flat::CreateLightInfo(
               _fbb,
               waitNum,
               dir,
               lightStates__,
               desc__);
}

struct TrafficLightCountdown FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef TrafficLightCountdownBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_PATHID = 4,
        VT_STATUS = 6,
        VT_LINKID = 8,
        VT_SEGMENTINDEX = 10,
        VT_LINKINDEX = 12,
        VT_POSITION = 14,
        VT_LIGHTINFO = 16
    };
    int64_t pathID() const
    {
        return GetField<int64_t>(VT_PATHID, 0);
    }
    int32_t status() const
    {
        return GetField<int32_t>(VT_STATUS, 0);
    }
    int64_t linkID() const
    {
        return GetField<int64_t>(VT_LINKID, 0);
    }
    int64_t segmentIndex() const
    {
        return GetField<int64_t>(VT_SEGMENTINDEX, 0);
    }
    int64_t linkIndex() const
    {
        return GetField<int64_t>(VT_LINKINDEX, 0);
    }
    const com::nio::map::adas::flat::GPSLocation* position() const
    {
        return GetPointer<const com::nio::map::adas::flat::GPSLocation*>(VT_POSITION);
    }
    const com::nio::map::adas::flat::LightInfo* lightInfo() const
    {
        return GetPointer<const com::nio::map::adas::flat::LightInfo*>(VT_LIGHTINFO);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<int64_t>(verifier, VT_PATHID, 8) &&
               VerifyField<int32_t>(verifier, VT_STATUS, 4) &&
               VerifyField<int64_t>(verifier, VT_LINKID, 8) &&
               VerifyField<int64_t>(verifier, VT_SEGMENTINDEX, 8) &&
               VerifyField<int64_t>(verifier, VT_LINKINDEX, 8) &&
               VerifyOffset(verifier, VT_POSITION) &&
               verifier.VerifyTable(position()) &&
               VerifyOffset(verifier, VT_LIGHTINFO) &&
               verifier.VerifyTable(lightInfo()) &&
               verifier.EndTable();
    }
};

struct TrafficLightCountdownBuilder
{
    typedef TrafficLightCountdown Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_pathID(int64_t pathID)
    {
        fbb_.AddElement<int64_t>(TrafficLightCountdown::VT_PATHID, pathID, 0);
    }
    void add_status(int32_t status)
    {
        fbb_.AddElement<int32_t>(TrafficLightCountdown::VT_STATUS, status, 0);
    }
    void add_linkID(int64_t linkID)
    {
        fbb_.AddElement<int64_t>(TrafficLightCountdown::VT_LINKID, linkID, 0);
    }
    void add_segmentIndex(int64_t segmentIndex)
    {
        fbb_.AddElement<int64_t>(TrafficLightCountdown::VT_SEGMENTINDEX, segmentIndex, 0);
    }
    void add_linkIndex(int64_t linkIndex)
    {
        fbb_.AddElement<int64_t>(TrafficLightCountdown::VT_LINKINDEX, linkIndex, 0);
    }
    void add_position(::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation> position)
    {
        fbb_.AddOffset(TrafficLightCountdown::VT_POSITION, position);
    }
    void add_lightInfo(::flatbuffers::Offset<com::nio::map::adas::flat::LightInfo> lightInfo)
    {
        fbb_.AddOffset(TrafficLightCountdown::VT_LIGHTINFO, lightInfo);
    }
    explicit TrafficLightCountdownBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<TrafficLightCountdown> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<TrafficLightCountdown>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<TrafficLightCountdown> CreateTrafficLightCountdown(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    int64_t pathID = 0,
    int32_t status = 0,
    int64_t linkID = 0,
    int64_t segmentIndex = 0,
    int64_t linkIndex = 0,
    ::flatbuffers::Offset<com::nio::map::adas::flat::GPSLocation> position = 0,
    ::flatbuffers::Offset<com::nio::map::adas::flat::LightInfo> lightInfo = 0)
{
    TrafficLightCountdownBuilder builder_(_fbb);
    builder_.add_linkIndex(linkIndex);
    builder_.add_segmentIndex(segmentIndex);
    builder_.add_linkID(linkID);
    builder_.add_pathID(pathID);
    builder_.add_lightInfo(lightInfo);
    builder_.add_position(position);
    builder_.add_status(status);
    return builder_.Finish();
}

struct TrafficLightCountdownList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef TrafficLightCountdownListBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_TRAFFICLIGHTCOUNTDOWNLIST = 4
    };
    const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::TrafficLightCountdown>>* trafficLightCountdownList() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::TrafficLightCountdown>> *>(VT_TRAFFICLIGHTCOUNTDOWNLIST);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyOffset(verifier, VT_TRAFFICLIGHTCOUNTDOWNLIST) &&
               verifier.VerifyVector(trafficLightCountdownList()) &&
               verifier.VerifyVectorOfTables(trafficLightCountdownList()) &&
               verifier.EndTable();
    }
};

struct TrafficLightCountdownListBuilder
{
    typedef TrafficLightCountdownList Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_trafficLightCountdownList(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::TrafficLightCountdown>>> trafficLightCountdownList)
    {
        fbb_.AddOffset(TrafficLightCountdownList::VT_TRAFFICLIGHTCOUNTDOWNLIST, trafficLightCountdownList);
    }
    explicit TrafficLightCountdownListBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<TrafficLightCountdownList> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<TrafficLightCountdownList>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<TrafficLightCountdownList> CreateTrafficLightCountdownList(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::nio::map::adas::flat::TrafficLightCountdown>>> trafficLightCountdownList = 0)
{
    TrafficLightCountdownListBuilder builder_(_fbb);
    builder_.add_trafficLightCountdownList(trafficLightCountdownList);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<TrafficLightCountdownList> CreateTrafficLightCountdownListDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<::flatbuffers::Offset<com::nio::map::adas::flat::TrafficLightCountdown>>* trafficLightCountdownList = nullptr)
{
    auto trafficLightCountdownList__ = trafficLightCountdownList ? _fbb.CreateVector<::flatbuffers::Offset<com::nio::map::adas::flat::TrafficLightCountdown>>(*trafficLightCountdownList) : 0;
    return com::nio::map::adas::flat::CreateTrafficLightCountdownList(
               _fbb,
               trafficLightCountdownList__);
}

struct ParallelRoad FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef ParallelRoadBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_BRIDGE_SWITCH_BUTTON = 4,
        VT_MAIN_ROAD_SWITCH_BUTTON = 6
    };
    int32_t bridge_switch_button() const
    {
        return GetField<int32_t>(VT_BRIDGE_SWITCH_BUTTON, 0);
    }
    int32_t main_road_switch_button() const
    {
        return GetField<int32_t>(VT_MAIN_ROAD_SWITCH_BUTTON, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<int32_t>(verifier, VT_BRIDGE_SWITCH_BUTTON, 4) &&
               VerifyField<int32_t>(verifier, VT_MAIN_ROAD_SWITCH_BUTTON, 4) &&
               verifier.EndTable();
    }
};

struct ParallelRoadBuilder
{
    typedef ParallelRoad Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_bridge_switch_button(int32_t bridge_switch_button)
    {
        fbb_.AddElement<int32_t>(ParallelRoad::VT_BRIDGE_SWITCH_BUTTON, bridge_switch_button, 0);
    }
    void add_main_road_switch_button(int32_t main_road_switch_button)
    {
        fbb_.AddElement<int32_t>(ParallelRoad::VT_MAIN_ROAD_SWITCH_BUTTON, main_road_switch_button, 0);
    }
    explicit ParallelRoadBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<ParallelRoad> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<ParallelRoad>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<ParallelRoad> CreateParallelRoad(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    int32_t bridge_switch_button = 0,
    int32_t main_road_switch_button = 0)
{
    ParallelRoadBuilder builder_(_fbb);
    builder_.add_main_road_switch_button(main_road_switch_button);
    builder_.add_bridge_switch_button(bridge_switch_button);
    return builder_.Finish();
}

inline bool VerifyNodeInfo(::flatbuffers::Verifier& verifier, const void* obj, NodeInfo type)
{
    switch (type)
    {
        case NodeInfo_NONE:
        {
            return true;
        }

        case NodeInfo_mapMatchInfo:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::MapMatchInfo*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case NodeInfo_speedLimitInfo:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::SpeedLimitInfo*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case NodeInfo_laneInfo:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::LaneInfo*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case NodeInfo_turnInfo:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::TurnInfo*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case NodeInfo_enterNopRoadInfo:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::EnterNopRoadInfo*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case NodeInfo_exitNopRoadInfo:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::ExitNopRoadInfo*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case NodeInfo_enterNopRampInfo:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::EnterNopRampInfo*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case NodeInfo_heartBeatInfo:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::HeartBeatInfo*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case NodeInfo_laneInfoList:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::LaneInfoList*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case NodeInfo_parallelRoad:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::ParallelRoad*>(obj);
            return verifier.VerifyTable(ptr);
        }

        default:
            return true;
    }
}

inline bool VerifyNodeInfoVector(::flatbuffers::Verifier& verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>>* values, const ::flatbuffers::Vector<uint8_t>* types)
{
    if (!values || !types) return !values && !types;

    if (values->size() != types->size()) return false;

    for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i)
    {
        if (!VerifyNodeInfo(
                verifier,  values->Get(i), types->GetEnum<NodeInfo>(i)))
        {
            return false;
        }
    }

    return true;
}

inline bool VerifyAdasInfo(::flatbuffers::Verifier& verifier, const void* obj, AdasInfo type)
{
    switch (type)
    {
        case AdasInfo_NONE:
        {
            return true;
        }

        case AdasInfo_trafficSign:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::TrafficSign*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case AdasInfo_position:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::Position*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case AdasInfo_segment:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::Segment*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case AdasInfo_stub:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::Stub*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case AdasInfo_profileShort:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::ProfileShort*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case AdasInfo_profileLong:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::ProfileLong*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case AdasInfo_metaData:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::MetaData*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case AdasInfo_customMessage:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::CustomMessage*>(obj);
            return verifier.VerifyTable(ptr);
        }

        default:
            return true;
    }
}

inline bool VerifyAdasInfoVector(::flatbuffers::Verifier& verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>>* values, const ::flatbuffers::Vector<uint8_t>* types)
{
    if (!values || !types) return !values && !types;

    if (values->size() != types->size()) return false;

    for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i)
    {
        if (!VerifyAdasInfo(
                verifier,  values->Get(i), types->GetEnum<AdasInfo>(i)))
        {
            return false;
        }
    }

    return true;
}

inline bool VerifyNopInfo(::flatbuffers::Verifier& verifier, const void* obj, NopInfo type)
{
    switch (type)
    {
        case NopInfo_NONE:
        {
            return true;
        }

        case NopInfo_highPrecisionMapQueryRequest:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::HighPrecisionMapQueryRequest*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case NopInfo_highPrecisionMapQueryResponse:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::HighPrecisionMapQueryResponse*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case NopInfo_highPrecisionMapPointList:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::HighPrecisionMapPointList*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case NopInfo_nowLocationHPMapStatus:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::NowLocationHPMapStatus*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case NopInfo_highPrecisionQueryMapEnterRequest:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::HighPrecisionMapQueryRequest*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case NopInfo_highPrecisionQueryMapEnterResponse:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::HighPrecisionQueryEnterResponse*>(obj);
            return verifier.VerifyTable(ptr);
        }

        default:
            return true;
    }
}

inline bool VerifyNopInfoVector(::flatbuffers::Verifier& verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>>* values, const ::flatbuffers::Vector<uint8_t>* types)
{
    if (!values || !types) return !values && !types;

    if (values->size() != types->size()) return false;

    for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i)
    {
        if (!VerifyNopInfo(
                verifier,  values->Get(i), types->GetEnum<NopInfo>(i)))
        {
            return false;
        }
    }

    return true;
}

inline bool VerifyFourDCruisePointsData(::flatbuffers::Verifier& verifier, const void* obj, FourDCruisePointsData type)
{
    switch (type)
    {
        case FourDCruisePointsData_NONE:
        {
            return true;
        }

        case FourDCruisePointsData_road_name_request:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::SearchByRoadNameRequest*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case FourDCruisePointsData_route_request:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::SearchByRouteRequest*>(obj);
            return verifier.VerifyTable(ptr);
        }

        default:
            return true;
    }
}

inline bool VerifyFourDCruisePointsDataVector(::flatbuffers::Verifier& verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>>* values, const ::flatbuffers::Vector<uint8_t>* types)
{
    if (!values || !types) return !values && !types;

    if (values->size() != types->size()) return false;

    for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i)
    {
        if (!VerifyFourDCruisePointsData(
                verifier,  values->Get(i), types->GetEnum<FourDCruisePointsData>(i)))
        {
            return false;
        }
    }

    return true;
}

inline bool VerifySDMapInfo(::flatbuffers::Verifier& verifier, const void* obj, SDMapInfo type)
{
    switch (type)
    {
        case SDMapInfo_NONE:
        {
            return true;
        }

        case SDMapInfo_nodeInfo:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::NodeInfoData*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case SDMapInfo_adasInfo:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::AdasInfoData*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case SDMapInfo_nopInfo:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::NopInfoData*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case SDMapInfo_mapLoc:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::NavMapLocVersion2*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case SDMapInfo_routeMatchRequest:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::RouteMatchRequest*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case SDMapInfo_routeMatchResponse:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::RouteMatchResponse*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case SDMapInfo_nadInfo:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::NADInfo*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case SDMapInfo_roadConditionInfo:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::RoadConditionInfo*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case SDMapInfo_resetPredictiveTree:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::ResetPredictiveTree*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case SDMapInfo_hdRoutesEvents:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::HDRoutesEvents*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case SDMapInfo_bumpyPois:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::BumpyPoisInfo*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case SDMapInfo_trafficLightCountdown:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::TrafficLightCountdownList*>(obj);
            return verifier.VerifyTable(ptr);
        }

        case SDMapInfo_fourDCruisePointsRequest:
        {
            auto ptr = reinterpret_cast<const com::nio::map::adas::flat::FourDCruisePointsRequest*>(obj);
            return verifier.VerifyTable(ptr);
        }

        default:
            return true;
    }
}

inline bool VerifySDMapInfoVector(::flatbuffers::Verifier& verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>>* values, const ::flatbuffers::Vector<uint8_t>* types)
{
    if (!values || !types) return !values && !types;

    if (values->size() != types->size()) return false;

    for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i)
    {
        if (!VerifySDMapInfo(
                verifier,  values->Get(i), types->GetEnum<SDMapInfo>(i)))
        {
            return false;
        }
    }

    return true;
}

inline const com::nio::map::adas::flat::SDMapTable* GetSDMapTable(const void* buf)
{
    return ::flatbuffers::GetRoot<com::nio::map::adas::flat::SDMapTable>(buf);
}

inline const com::nio::map::adas::flat::SDMapTable* GetSizePrefixedSDMapTable(const void* buf)
{
    return ::flatbuffers::GetSizePrefixedRoot<com::nio::map::adas::flat::SDMapTable>(buf);
}

inline bool VerifySDMapTableBuffer(
    ::flatbuffers::Verifier& verifier)
{
    return verifier.VerifyBuffer<com::nio::map::adas::flat::SDMapTable>(nullptr);
}

inline bool VerifySizePrefixedSDMapTableBuffer(
    ::flatbuffers::Verifier& verifier)
{
    return verifier.VerifySizePrefixedBuffer<com::nio::map::adas::flat::SDMapTable>(nullptr);
}

inline void FinishSDMapTableBuffer(
    ::flatbuffers::FlatBufferBuilder& fbb,
    ::flatbuffers::Offset<com::nio::map::adas::flat::SDMapTable> root)
{
    fbb.Finish(root);
}

inline void FinishSizePrefixedSDMapTableBuffer(
    ::flatbuffers::FlatBufferBuilder& fbb,
    ::flatbuffers::Offset<com::nio::map::adas::flat::SDMapTable> root)
{
    fbb.FinishSizePrefixed(root);
}

}  // namespace flat
}  // namespace adas
}  // namespace map
}  // namespace nio
}  // namespace com

#endif  // FLATBUFFERS_GENERATED_ADCBRIDGE_COM_NIO_MAP_ADAS_FLAT_H_
